<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>岁月如冰河</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://double1000.github.io/blog/"/>
  <updated>2017-05-19T03:11:38.789Z</updated>
  <id>https://double1000.github.io/blog/</id>
  
  <author>
    <name>胡温柔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript | 常用函数/技巧 - Chapter 1</title>
    <link href="https://double1000.github.io/blog/2017/05/18/js-%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7-1/"/>
    <id>https://double1000.github.io/blog/2017/05/18/js-常见实用技巧-1/</id>
    <published>2017-05-18T00:44:09.000Z</published>
    <updated>2017-05-19T03:11:38.789Z</updated>
    
    <content type="html"><![CDATA[<pre><code>金钱“格式转换,获取主域名,window.onload使用多次,insertafter在结点后面插入内容,实现字符串长度截取并在结尾添加,设置获取cookie值......
</code></pre><h4 id="”金钱“格式转换"><a href="#”金钱“格式转换" class="headerlink" title="”金钱“格式转换"></a>”金钱“格式转换</h4><p><code>运用点：</code>所谓的金钱格式转换就是把数字转换成三位数加一个逗号的格式，使数据变得很直观明了~<br><code>例子:</code>数据是字符串的，加减钱需要用正则转换成数字，但是再显示最后结果时，也需要再次转换成金钱的格式，再通过ajax实现数据的交互。下面来看下怎么实现的 这个是正则，把字符串转换成数字之后，能直接进行运算:如把1,561,124转换成1561124<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">下面的这个是数字转换成金钱格式的函数，也很容易理解</div><div class="line">function formatCash(cash)&#123;</div><div class="line">    var str_cash = cash + &quot;&quot;;//转换成字符串</div><div class="line">    var ret_cash = &quot;&quot;;</div><div class="line">    var counter = 0;</div><div class="line">    for(var i=str_cash.length-1;i&gt;=0;i--)&#123;</div><div class="line">        ret_cash = str_cash.charAt(i) + ret_cash;</div><div class="line">        counter++;</div><div class="line">        if(counter==3)&#123;</div><div class="line">            counter = 0;</div><div class="line">            if(i!=0)&#123;</div><div class="line">            ret_cash = &quot;,&quot; + ret_cash;</div><div class="line">            &#125;</div><div class="line">        &#125;&#125;</div><div class="line">    return ret_cash;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// demo:</div><div class="line">var num = 1012145;</div><div class="line">formatCash(num);   //1,012,145</div></pre></td></tr></table></figure></p>
<h4 id="window-onload使用多次"><a href="#window-onload使用多次" class="headerlink" title="window.onload使用多次"></a>window.onload使用多次</h4><p><code>运用点：</code>window.onload只能使用一次，而不像JQ那样能只用多次，下面的这个函数就可以实现多次使用onload的功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function addLoadEvent(func) &#123;</div><div class="line">    var oldonload = window.onload;</div><div class="line">    if (typeof window.onload != &apos;function&apos;) &#123;</div><div class="line">        window.onload = func;</div><div class="line">    &#125; else &#123;</div><div class="line">        window.onload = function() &#123;</div><div class="line">            oldonload();</div><div class="line">            func();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// demo：</div><div class="line">addLoadEvent(fnName);  //可使用多次</div></pre></td></tr></table></figure></p>
<h4 id="insertafter在结点后面插入内容"><a href="#insertafter在结点后面插入内容" class="headerlink" title="insertafter在结点后面插入内容"></a>insertafter在结点后面插入内容</h4><p><code>运用点：</code>js给我们提供了insertbefore，没有after，下面这个函数就实现了这个功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// insertAfter</div><div class="line">    function insertAfter(newElement,targetElement)&#123;</div><div class="line">        var parent=targetElement.parentNode;</div><div class="line">        if(parent.lastChild==targetElement)&#123;</div><div class="line">            parent.appendChild(newElement);</div><div class="line">           &#125; else &#123;</div><div class="line">            parent.insertBefore(newElement,targetElement.nextSibling);</div><div class="line">        &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<h4 id="实现字符串长度截取并在结尾添加…"><a href="#实现字符串长度截取并在结尾添加…" class="headerlink" title="实现字符串长度截取并在结尾添加…"></a>实现字符串长度截取并在结尾添加…</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">cutstr</span>(<span class="params">str, len</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> temp;</div><div class="line"><span class="keyword">var</span> icount = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> patrn = <span class="regexp">/[^\x00-\xff]/</span>;  <span class="comment">//表示汉字或者全角，即ASCII 编码不在0-255的字符</span></div><div class="line"><span class="keyword">var</span> strre = <span class="string">""</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (icount &lt; len) &#123;</div><div class="line">        <span class="comment">// 每次截取一个字符</span></div><div class="line">        temp = str.substr(i, <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (patrn.exec(temp) == <span class="literal">null</span>) &#123;</div><div class="line">            <span class="comment">// 如果是英文、半角</span></div><div class="line">            icount = icount + <span class="number">1</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 如果是中文、全角</span></div><div class="line">            icount = icount + <span class="number">2</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 字符串连接</span></div><div class="line">        strre += temp</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">break</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> strre + <span class="string">"..."</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// demo:</span></div><div class="line">cutstr(<span class="string">"xuanfeng"</span>, <span class="number">2</span>)  <span class="comment">//xu...</span></div><div class="line">cutstr(<span class="string">"轩枫阁"</span>, <span class="number">3</span>)    <span class="comment">//轩枫...</span></div></pre></td></tr></table></figure>
<h4 id="获取主域名"><a href="#获取主域名" class="headerlink" title="获取主域名"></a>获取主域名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function getHost(url) &#123;</div><div class="line">    var host = &quot;null&quot;;</div><div class="line">    if(typeof url == &quot;undefined&quot;|| null == url) &#123;</div><div class="line">        url = window.location.href;</div><div class="line">    &#125;</div><div class="line">    var regex = /^\w+\:\/\/([^\/]*).*/;</div><div class="line">    var match = url.match(regex);</div><div class="line">    if(typeof match != &quot;undefined&quot; &amp;&amp; null != match) &#123;</div><div class="line">        host = match[1];</div><div class="line">    &#125;</div><div class="line">    return host;</div><div class="line">&#125;</div><div class="line">// demo:</div><div class="line">getHost(&quot;http://www.xuanfengge.com/page/2&quot;)   //www.xuanfengge.com</div></pre></td></tr></table></figure>
<h4 id="时间日期格式转换"><a href="#时间日期格式转换" class="headerlink" title="时间日期格式转换"></a>时间日期格式转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Date.prototype.Format = function(formatStr) &#123;</div><div class="line">    var str = formatStr;</div><div class="line">    var Week = [&apos;日&apos;, &apos;一&apos;, &apos;二&apos;, &apos;三&apos;, &apos;四&apos;, &apos;五&apos;, &apos;六&apos;];</div><div class="line">    str = str.replace(/yyyy|YYYY/, this.getFullYear());</div><div class="line">    str = str.replace(/yy|YY/, (this.getYear() % 100) &gt; 9 ? (this.getYear() % 100).toString() : &apos;0&apos; + (this.getYear() % 100));</div><div class="line">    str = str.replace(/MM/, (this.getMonth() + 1) &gt; 9 ? (this.getMonth() + 1).toString() : &apos;0&apos; + (this.getMonth() + 1));</div><div class="line">    str = str.replace(/M/g, (this.getMonth() + 1));</div><div class="line">    str = str.replace(/w|W/g, Week[this.getDay()]);</div><div class="line">    str = str.replace(/dd|DD/, this.getDate() &gt; 9 ? this.getDate().toString() : &apos;0&apos; + this.getDate());</div><div class="line">    str = str.replace(/d|D/g, this.getDate());</div><div class="line">    str = str.replace(/hh|HH/, this.getHours() &gt; 9 ? this.getHours().toString() : &apos;0&apos; + this.getHours());</div><div class="line">    str = str.replace(/h|H/g, this.getHours());</div><div class="line">    str = str.replace(/mm/, this.getMinutes() &gt; 9 ? this.getMinutes().toString() : &apos;0&apos; + this.getMinutes());</div><div class="line">    str = str.replace(/m/g, this.getMinutes());</div><div class="line">    str = str.replace(/ss|SS/, this.getSeconds() &gt; 9 ? this.getSeconds().toString() : &apos;0&apos; + this.getSeconds());</div><div class="line">    str = str.replace(/s|S/g, this.getSeconds());</div><div class="line">    return str;</div><div class="line">&#125;</div><div class="line">// demo:</div><div class="line">var date = new Date();</div><div class="line">date.Format(&quot;YYYY-M-D&quot;);    //2013-5-8</div><div class="line">date.Format(&quot;YYYY-MM-DD&quot;);  //2013-11-08</div></pre></td></tr></table></figure>
<h4 id="设置cookie值"><a href="#设置cookie值" class="headerlink" title="设置cookie值"></a>设置cookie值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function setCookie(name, value, Hours) &#123;</div><div class="line">    var d = new Date();</div><div class="line">    var offset = 8;</div><div class="line">    var utc = d.getTime() + (d.getTimezoneOffset() * 60000);</div><div class="line">    var nd = utc + (3600000 * offset);</div><div class="line">    var exp = new Date(nd);</div><div class="line">    exp.setTime(exp.getTime() + Hours * 60 * 60 * 1000);</div><div class="line">    document.cookie = name + &quot;=&quot; + escape(value) + &quot;;path=/;expires=&quot; + exp.toGMTString() + &quot;;domain=xuanfengge.com;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取cookie值"><a href="#获取cookie值" class="headerlink" title="获取cookie值"></a>获取cookie值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function getCookie(name) &#123;</div><div class="line">    var arr = document.cookie.match(new RegExp(&quot;(^| )&quot; + name + &quot;=([^;]*)(;|$)&quot;));</div><div class="line">    if (arr != null) return unescape(arr[2]);</div><div class="line">    return null</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;金钱“格式转换,获取主域名,window.onload使用多次,insertafter在结点后面插入内容,实现字符串长度截取并在结尾添加,设置获取cookie值......
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;”金钱“格式转换&quot;&gt;&lt;a href=&quot;#”
    
    </summary>
    
      <category term="JavaScript | 常用函数收集系列" scheme="https://double1000.github.io/blog/categories/JavaScript-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%94%B6%E9%9B%86%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JavaScript" scheme="https://double1000.github.io/blog/tags/JavaScript/"/>
    
      <category term="技巧" scheme="https://double1000.github.io/blog/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript | 常用函数/技巧 - Chapter 5</title>
    <link href="https://double1000.github.io/blog/2017/05/18/js-%E6%8A%80%E5%B7%A7%E6%94%B6%E9%9B%86-5/"/>
    <id>https://double1000.github.io/blog/2017/05/18/js-技巧收集-5/</id>
    <published>2017-05-18T00:44:09.000Z</published>
    <updated>2017-05-19T03:28:40.122Z</updated>
    
    <content type="html"><![CDATA[<pre><code>数组去重,生成范围类的随机数,矩形的碰撞区域检测,兼容获取属性......
</code></pre><h4 id="生成范围类的随机数"><a href="#生成范围类的随机数" class="headerlink" title="生成范围类的随机数"></a>生成范围类的随机数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function randomValue(max,min) &#123;</div><div class="line">    var x = Math.floor(Math.random() * (max - min + 1)) + min;</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="兼容获取属性"><a href="#兼容获取属性" class="headerlink" title="兼容获取属性"></a>兼容获取属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function getStyle(obj,attr)&#123;</div><div class="line">    if(window.getComputedStyle)&#123;</div><div class="line">        return getComputedStyle(obj,null)[attr];</div><div class="line">    &#125;</div><div class="line">    return obj.currentStyle[attr];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="矩形的碰撞区域检测-碰撞到返回true-没碰到返回false"><a href="#矩形的碰撞区域检测-碰撞到返回true-没碰到返回false" class="headerlink" title="矩形的碰撞区域检测 碰撞到返回true 没碰到返回false"></a>矩形的碰撞区域检测 碰撞到返回true 没碰到返回false</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function pz(obj1,obj2)&#123;</div><div class="line">    var L1 = obj1.offsetLeft;</div><div class="line">    var R1 = obj1.offsetLeft + obj1.offsetWidth;</div><div class="line">    var T1 = obj1.offsetTop;</div><div class="line">    var B1 = obj1.offsetTop + obj1.offsetHeight;</div><div class="line"></div><div class="line">    var L2 = obj2.offsetLeft;</div><div class="line">    var R2 = obj2.offsetLeft + obj2.offsetWidth;</div><div class="line">    var T2 = obj2.offsetTop;</div><div class="line">    var B2 = obj2.offsetTop + obj2.offsetHeight;</div><div class="line"></div><div class="line">    if( R1&lt;L2 || L1&gt;R2 || B1&lt;T2 || T1&gt;B2 )&#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#### </p>
<h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">第一种：indexof</div><div class="line">function unique(a) &#123;</div><div class="line">  var res = [];</div><div class="line"> </div><div class="line">  for (var i = 0, len = a.length; i &lt; len; i++) &#123;</div><div class="line">    var item = a[i];</div><div class="line">    (res.indexOf(item) === -1) &amp;&amp; res.push(item);</div><div class="line">  &#125;</div><div class="line">  return res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = [1, 1, &apos;1&apos;, &apos;2&apos;, 1];</div><div class="line">var ans = unique(a);</div><div class="line">console.log(ans); // =&gt; [1, &quot;1&quot;, &quot;2&quot;]</div><div class="line"></div><div class="line">第二种：两层循环检测重复元素法</div><div class="line">function distinct(arr) &#123;</div><div class="line">    var ret = [],</div><div class="line">        length = arr.length;</div><div class="line">    for(var i = 0;i &lt; length; i++)&#123;</div><div class="line">        for(j = i+1; j&lt;length;j++)&#123;</div><div class="line">            if(arr[i] === arr[j])&#123;</div><div class="line">                j = ++i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ret.push(arr[i]);</div><div class="line">    &#125;</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line">var arra = [1,2,3,4,4,1,1,2,1,1,1];</div><div class="line">distinct(arra); //返回[3,4,2,1]</div><div class="line"></div><div class="line">第三种：indexof</div><div class="line">function unique(array)&#123;</div><div class="line">    var n = [];//临时数组</div><div class="line">    for(var i = 0;i &lt; array.length; i++)&#123;</div><div class="line">        if(n.indexOf(array[i]) == -1) n.push(array[i]);</div><div class="line">    &#125;</div><div class="line">    return n;</div><div class="line">&#125;</div><div class="line"></div><div class="line">第四种： ES6</div><div class="line">function unique (arr) &#123;</div><div class="line">  const seen = new Map()</div><div class="line">  return arr.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))</div><div class="line">&#125;</div><div class="line">// or</div><div class="line">function unique (arr) &#123;</div><div class="line">  return Array.from(new Set(arr))</div><div class="line">&#125;</div><div class="line"></div><div class="line">第五种：对象KEY值去重</div><div class="line">Array.prototype.unique3 = function()&#123;</div><div class="line"> var res = [];</div><div class="line"> var json = &#123;&#125;;</div><div class="line"> for(var i = 0; i &lt; this.length; i++)&#123;</div><div class="line">  if(!json[this[i]])&#123;</div><div class="line">   res.push(this[i]);</div><div class="line">   json[this[i]] = 1;</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"> return res;</div><div class="line">&#125;</div><div class="line">var arr = [112,112,34,&apos;你好&apos;,112,112,34,&apos;你好&apos;,&apos;str&apos;,&apos;str1&apos;];</div><div class="line">alert(arr.unique3());</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;数组去重,生成范围类的随机数,矩形的碰撞区域检测,兼容获取属性......
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;生成范围类的随机数&quot;&gt;&lt;a href=&quot;#生成范围类的随机数&quot; class=&quot;headerlink&quot; title=&quot;生成范围类的随机数&quot;&gt;&lt;
    
    </summary>
    
      <category term="JavaScript | 常用函数收集系列" scheme="https://double1000.github.io/blog/categories/JavaScript-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%94%B6%E9%9B%86%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JavaScript" scheme="https://double1000.github.io/blog/tags/JavaScript/"/>
    
      <category term="技巧" scheme="https://double1000.github.io/blog/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript | 常用函数/技巧 - Chapter 3</title>
    <link href="https://double1000.github.io/blog/2017/05/18/js-%E6%8A%80%E5%B7%A7%E6%94%B6%E9%9B%86-3/"/>
    <id>https://double1000.github.io/blog/2017/05/18/js-技巧收集-3/</id>
    <published>2017-05-18T00:44:09.000Z</published>
    <updated>2017-05-19T03:18:32.044Z</updated>
    
    <content type="html"><![CDATA[<pre><code>常用的正则表达式,操作DOM类,getByClass，getById，getByTag,实现base64解码,格式化数字，金额......
</code></pre><h4 id="操作DOM类"><a href="#操作DOM类" class="headerlink" title="操作DOM类"></a>操作DOM类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 判断某个对象是否有指定的className</div><div class="line">function hasClass(ele,cls) &#123;</div><div class="line">    return ele.className.match(new RegExp(&apos;(\\s|^)&apos;+cls+&apos;(\\s|$)&apos;));</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 给指定对象添加className</div><div class="line">function addClass(ele,cls) &#123;</div><div class="line">    if (!this.hasClass(ele,cls)) ele.className += &quot; &quot;+cls;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 删除className</div><div class="line">function removeClass(ele,cls) &#123;</div><div class="line">    if (hasClass(ele,cls)) &#123;</div><div class="line">        var reg = new RegExp(&apos;(\\s|^)&apos;+cls+&apos;(\\s|$)&apos;);</div><div class="line">        ele.className=ele.className.replace(reg,&apos; &apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="DOM-操作-根据获元素的class获取相应元素"><a href="#DOM-操作-根据获元素的class获取相应元素" class="headerlink" title="DOM 操作 根据获元素的class获取相应元素"></a>DOM 操作 根据获元素的class获取相应元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function getByClass(oParent,sClass) &#123;</div><div class="line">    var aEle = oParent.getElementsByTagName(&apos;*&apos;);</div><div class="line">    var aResult = [];</div><div class="line">    var re=new RegExp(&apos;\\b&apos;+sClass+&apos;\\b&apos;, &apos;i&apos;);</div><div class="line">    for(var i=0; i&lt;aEle.length;i++) &#123;</div><div class="line">        if(aEle[i].className.search(re)!=-1) &#123;</div><div class="line">            aResult.push(aEle[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return aResult;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="getByClass，getById，getByTag"><a href="#getByClass，getById，getByTag" class="headerlink" title="getByClass，getById，getByTag"></a>getByClass，getById，getByTag</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">var get=&#123;</div><div class="line">  byId:function(id)&#123;</div><div class="line">    return document.getElementById(id);</div><div class="line">  &#125;,</div><div class="line">  byClass:function(oParent,sClass)&#123;</div><div class="line">    if(oParent.getElementsByClass)&#123;</div><div class="line">      retuen (oParent||document).getElementsByClass(sClass);</div><div class="line">    &#125;else&#123;</div><div class="line">      var aClass=[];</div><div class="line">      var reClass=new  RegExp(&quot;(^|)&quot;+sClass+&quot;( |$)&quot;);</div><div class="line">      var aElem=this.byTag(oParent,&quot;*&quot;);</div><div class="line">      for(var i=0;i&lt;aElem.length;i++)&#123;</div><div class="line">        // reClass.test(aElem[i].className) &amp;&amp; aClass.push(aElem[i]);</div><div class="line">        if(reClass.test(aElem[i].className))&#123;</div><div class="line">          aClass.push(aElem[i]);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      return aClass;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  byTag:function(obj,elem)&#123;</div><div class="line">    return (obj||document).getElementsByTagName(elem);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// demo:</div><div class="line">var oNav = get.byId(&quot;nav&quot;);</div><div class="line">var aLi = get.byTagName(&quot;li&quot;, oNav);</div><div class="line">var aSubNav = get.byClass(&quot;subnav&quot;, oNav);</div></pre></td></tr></table></figure>
<h4 id="实现base64解码"><a href="#实现base64解码" class="headerlink" title="实现base64解码"></a>实现base64解码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function base64_decode(data)&#123;</div><div class="line">    var b64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;;</div><div class="line">    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,ac = 0,dec = &quot;&quot;,tmp_arr = [];</div><div class="line">    if (!data) &#123; return data; &#125;</div><div class="line">    data += &apos;&apos;;</div><div class="line">    do &#123;</div><div class="line">        h1 = b64.indexOf(data.charAt(i++));</div><div class="line">        h2 = b64.indexOf(data.charAt(i++));</div><div class="line">        h3 = b64.indexOf(data.charAt(i++));</div><div class="line">        h4 = b64.indexOf(data.charAt(i++));</div><div class="line">        bits = h1 &lt;&lt; 18 | h2 &lt;&lt; 12 | h3 &lt;&lt; 6 | h4;</div><div class="line">        o1 = bits &gt;&gt; 16 &amp; 0xff;</div><div class="line">        o2 = bits &gt;&gt; 8 &amp; 0xff;</div><div class="line">        o3 = bits &amp; 0xff;</div><div class="line">        if (h3 == 64) &#123;</div><div class="line">            tmp_arr[ac++] = String.fromCharCode(o1);</div><div class="line">        &#125; else if (h4 == 64) &#123;</div><div class="line">            tmp_arr[ac++] = String.fromCharCode(o1, o2);</div><div class="line">        &#125; else &#123;</div><div class="line">            tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);</div><div class="line">        &#125;</div><div class="line">    &#125; while (i &lt; data.length);</div><div class="line">    dec = tmp_arr.join(&apos;&apos;);</div><div class="line">    dec = utf8_decode(dec);</div><div class="line">    return dec;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取当前元素样式"><a href="#获取当前元素样式" class="headerlink" title="获取当前元素样式"></a>获取当前元素样式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function getStyle(oElm, strCssRule)&#123;</div><div class="line">    var strValue = &quot;&quot;;</div><div class="line">    if(document.defaultView &amp;&amp; document.defaultView.getComputedStyle)&#123;</div><div class="line">        strValue = document.defaultView.getComputedStyle(oElm, &quot;&quot;).getPropertyValue(strCssRule);</div><div class="line">    &#125;</div><div class="line">    else if(oElm.currentStyle)&#123;</div><div class="line">        strCssRule = strCssRule.replace(/\-(\w)/g, function (strMatch, p1)&#123;</div><div class="line">            return p1.toUpperCase();</div><div class="line">        &#125;);</div><div class="line">        strValue = oElm.currentStyle[strCssRule];</div><div class="line">    &#125;</div><div class="line">    return strValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">//正整数</div><div class="line">/^[0-9]*[1-9][0-9]*$/;</div><div class="line">//负整数</div><div class="line">/^-[0-9]*[1-9][0-9]*$/;</div><div class="line">//正浮点数</div><div class="line">/^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$/;</div><div class="line">//负浮点数</div><div class="line">/^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/;</div><div class="line">//浮点数</div><div class="line">/^(-?\d+)(\.\d+)?$/;</div><div class="line">//email地址</div><div class="line">/^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/;</div><div class="line">//url地址</div><div class="line">/^[a-zA-z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$/;</div><div class="line">或：^http:\/\/[A-Za-z0-9]+\.[A-Za-z0-9]+[\/=\?%\-&amp;_~`@[\]\&apos;:+!]*([^&lt;&gt;\&quot;\&quot;])*$</div><div class="line">//年/月/日（年-月-日、年.月.日）</div><div class="line">/^(19|20)\d\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$/;</div><div class="line">//匹配中文字符</div><div class="line">/[\u4e00-\u9fa5]/;</div><div class="line">//匹配帐号是否合法(字母开头，允许5-10字节，允许字母数字下划线)</div><div class="line">/^[a-zA-Z][a-zA-Z0-9_]&#123;4,9&#125;$/;</div><div class="line">//匹配空白行的正则表达式</div><div class="line">/\n\s*\r/;</div><div class="line">//匹配中国邮政编码</div><div class="line">/[1-9]\d&#123;5&#125;(?!\d)/;</div><div class="line">//匹配身份证</div><div class="line">/\d&#123;15&#125;|\d&#123;18&#125;/;</div><div class="line">//匹配国内电话号码</div><div class="line">/(\d&#123;3&#125;-|\d&#123;4&#125;-)?(\d&#123;8&#125;|\d&#123;7&#125;)?/;</div><div class="line">//匹配IP地址</div><div class="line">/((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?)/;</div><div class="line">//匹配首尾空白字符的正则表达式</div><div class="line">/^\s*|\s*$/;</div><div class="line">//匹配HTML标记的正则表达式</div><div class="line">&lt; (\S*?)[^&gt;]*&gt;.*?|&lt; .*? /&gt;;</div><div class="line">//sql 语句</div><div class="line">^(select|drop|delete|create|update|insert).*$</div><div class="line">//提取信息中的网络链接</div><div class="line">(h|H)(r|R)(e|E)(f|F) *= *(&apos;|&quot;)?(\w|\\|\/|\.)+(&apos;|&quot;| *|&gt;)?</div><div class="line">//提取信息中的邮件地址</div><div class="line">\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*</div><div class="line">//提取信息中的图片链接</div><div class="line">(s|S)(r|R)(c|C) *= *(&apos;|&quot;)?(\w|\\|\/|\.)+(&apos;|&quot;| *|&gt;)?</div><div class="line">//提取信息中的 IP 地址</div><div class="line">(\d+)\.(\d+)\.(\d+)\.(\d+)</div><div class="line">//取信息中的中国手机号码</div><div class="line">(86)*0*13\d&#123;9&#125;</div><div class="line">//提取信息中的中国邮政编码</div><div class="line">[1-9]&#123;1&#125;(\d+)&#123;5&#125;</div><div class="line">//提取信息中的浮点数（即小数）</div><div class="line">(-?\d*)\.?\d+</div><div class="line">//提取信息中的任何数字</div><div class="line">(-?\d*)(\.\d+)?</div><div class="line">//电话区号</div><div class="line">^0\d&#123;2,3&#125;$</div><div class="line">//腾讯 QQ 号</div><div class="line">^[1-9]*[1-9][0-9]*$</div><div class="line">//帐号（字母开头，允许 5-16 字节，允许字母数字下划线）</div><div class="line">^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</div><div class="line">//中文、英文、数字及下划线</div><div class="line">^[\u4e00-\u9fa5_a-zA-Z0-9]+$</div></pre></td></tr></table></figure>
<h4 id="格式化数字，金额"><a href="#格式化数字，金额" class="headerlink" title="格式化数字，金额"></a>格式化数字，金额</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">function number_format(number, decimals, dec_point, thousands_sep) &#123;</div><div class="line">    /*</div><div class="line">    * 参数说明：</div><div class="line">    * number：要格式化的数字</div><div class="line">    * decimals：保留几位小数</div><div class="line">    * dec_point：小数点符号</div><div class="line">    * thousands_sep：千分位符号</div><div class="line">    * */</div><div class="line">    number = (number + &apos;&apos;).replace(/[^0-9+-Ee.]/g, &apos;&apos;);</div><div class="line">    var n = !isFinite(+number) ? 0 : +number,</div><div class="line">        prec = !isFinite(+decimals) ? 0 : Math.abs(decimals),</div><div class="line">        sep = (typeof thousands_sep === &apos;undefined&apos;) ? &apos;,&apos; : thousands_sep,</div><div class="line">        dec = (typeof dec_point === &apos;undefined&apos;) ? &apos;.&apos; : dec_point,</div><div class="line">        s = &apos;&apos;,</div><div class="line">        toFixedFix = function (n, prec) &#123;</div><div class="line">            var k = Math.pow(10, prec);</div><div class="line">            return &apos;&apos; + Math.ceil(n * k) / k;</div><div class="line">        &#125;;</div><div class="line"> </div><div class="line">    s = (prec ? toFixedFix(n, prec) : &apos;&apos; + Math.round(n)).split(&apos;.&apos;);</div><div class="line">    var re = /(-?\d+)(\d&#123;3&#125;)/;</div><div class="line">    while (re.test(s[0])) &#123;</div><div class="line">        s[0] = s[0].replace(re, &quot;$1&quot; + sep + &quot;$2&quot;);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    if ((s[1] || &apos;&apos;).length &lt; prec) &#123;</div><div class="line">        s[1] = s[1] || &apos;&apos;;</div><div class="line">        s[1] += new Array(prec - s[1].length + 1).join(&apos;0&apos;);</div><div class="line">    &#125;</div><div class="line">    return s.join(dec);</div><div class="line">&#125;</div><div class="line">var num = number_format(1234567.089, 2, &quot;.&quot;, &quot;,&quot;);//1,234,567.09</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;常用的正则表达式,操作DOM类,getByClass，getById，getByTag,实现base64解码,格式化数字，金额......
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;操作DOM类&quot;&gt;&lt;a href=&quot;#操作DOM类&quot; class=&quot;heade
    
    </summary>
    
      <category term="JavaScript | 常用函数收集系列" scheme="https://double1000.github.io/blog/categories/JavaScript-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%94%B6%E9%9B%86%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JavaScript" scheme="https://double1000.github.io/blog/tags/JavaScript/"/>
    
      <category term="技巧" scheme="https://double1000.github.io/blog/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript | 常用函数/技巧 - Chapter 4</title>
    <link href="https://double1000.github.io/blog/2017/05/18/js-%E6%8A%80%E5%B7%A7%E6%94%B6%E9%9B%86-3-1/"/>
    <id>https://double1000.github.io/blog/2017/05/18/js-技巧收集-3-1/</id>
    <published>2017-05-18T00:44:09.000Z</published>
    <updated>2017-05-19T03:11:45.329Z</updated>
    
    <content type="html"><![CDATA[<pre><code>浅深拷贝的实现,原生extend实现,函数节流防抖......
</code></pre><h4 id="一个简单浅复制的实现"><a href="#一个简单浅复制的实现" class="headerlink" title="一个简单浅复制的实现"></a>一个简单浅复制的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var  obj = &#123;a:&apos;1&apos;,arr:[2,3]&#125;;</div><div class="line">  var shadowObj = shadowCopy(obj);</div><div class="line"></div><div class="line">  function shadowCopy(src) &#123;</div><div class="line">    var dst = &#123;&#125;;</div><div class="line">    for(var prop in src)&#123;</div><div class="line">      if(src.hasOwnProperty(prop))&#123;</div><div class="line">        dst[prop] =  src[prop];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return dst;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<h4 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function deepCopy(obj)&#123;</div><div class="line">    var str,</div><div class="line">        newObj = obj.constructor === Array ? [] : &#123;&#125;;</div><div class="line">    if(typeof obj != &apos;object&apos;)&#123;</div><div class="line">        return;</div><div class="line">    &#125;else if(window.JSON)&#123;</div><div class="line">        str = JSON.stringify(obj);</div><div class="line">        // 序列化对象</div><div class="line">        newObj = JSON.parse(str);</div><div class="line">        // 还原</div><div class="line">    &#125;else&#123;</div><div class="line">        for(var i in obj)&#123;</div><div class="line">            newObj[i] = typeof obj[i] === &apos;object&apos; ? deepCopy(obj) : obj[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return newObj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">1.首先深复制和浅复制只针对像Object,Array这种复杂对象的</div><div class="line">2.简单来说，浅复制只复制呢一层对象的属性，而深复制则是递归的复制了所有层级</div></pre></td></tr></table></figure>
<h4 id="原生js实现复制对象、扩展对象-类似jquery中的extend-方法"><a href="#原生js实现复制对象、扩展对象-类似jquery中的extend-方法" class="headerlink" title="原生js实现复制对象、扩展对象 类似jquery中的extend()方法"></a>原生js实现复制对象、扩展对象 类似jquery中的extend()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var o1 = &#123;hello:1,old:555&#125;,</div><div class="line">        o2 = &#123;abc:555555,hello:2,fun:function () &#123;alert(&apos;111&apos;);&#125;&#125;,</div><div class="line">        o3 = &#123;third:9999&#125;;</div><div class="line">    /*复制对象方法*/</div><div class="line">    function cloneObj(oldObj) &#123;</div><div class="line">        var newObj = &#123;&#125;;</div><div class="line">        if(typeof oldObj != &apos;Object&apos; || oldObj == null) return oldObj;</div><div class="line">        for(var i in oldObj) &#123;</div><div class="line">            newObj[i] = cloneObj(oldObj[i]);</div><div class="line">        &#125;</div><div class="line">        return newObj;</div><div class="line">    &#125;</div><div class="line">    /*扩展对象*/</div><div class="line">    function extend() &#123;</div><div class="line">        var args = arguments;</div><div class="line">       if(args.length &lt; 2) return;</div><div class="line">       // 调用复制对象方法</div><div class="line">       var temp = cloneObj(args[0]);</div><div class="line">       for(var n = 1;n&lt;args.length;n++) &#123;</div><div class="line">           for(var i in args[n])&#123;</div><div class="line">               temp[i] = args[n][i];</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       return temp;</div><div class="line">    &#125;</div><div class="line">   extend(o1,o2,o3);</div></pre></td></tr></table></figure>
<h4 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流 throttle"></a>函数节流 throttle</h4><p><code>应用点:</code>保证每 X 毫秒恒定的执行次数，比如每200ms检查下滚动位置，并触发 CSS 动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 函数节流:只允许一个函数在 X 毫秒内执行一次。且再Time时间内必须执行一次</div><div class="line"> * @param fun 要执行的函数</div><div class="line"> * @param delay 延迟多久时间执行一次</div><div class="line"> * @param time  在timer时间内必须执行一次</div><div class="line"> * @returns &#123;Function&#125;</div><div class="line"> */</div><div class="line"> </div><div class="line">var throttle = function (fun,delay,time) &#123;</div><div class="line">    var timeout,</div><div class="line">        startTime = new Date();</div><div class="line">    return function () &#123;</div><div class="line">        var context = this,</div><div class="line">            args = arguments,</div><div class="line">            curTime = new Date();</div><div class="line">        clearTimeout(timeout);</div><div class="line">        // 如果达到了规定的触发时间间隔，触发handler</div><div class="line">        if(curTime - startTime &gt;= time)&#123;</div><div class="line">            fun.apply(context,args);</div><div class="line">            startTime = curTime;</div><div class="line">            // 没达到出发间隔，重写设定定时器</div><div class="line">        &#125;else&#123;</div><div class="line">            timeout = setTimeout(fun,delay);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖 debounce"></a>函数防抖 debounce</h4><p><code>应用点:</code>把触发非常频繁的事件（比如按键）合并成一次执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 函数防抖:只允许一个函数在 X 毫秒内执行一次。且再Time时间内必须执行一次</div><div class="line"> * @param fn 要执行的函数</div><div class="line"> * @param delay 延迟多久时间执行一次</div><div class="line"> */</div><div class="line">function debounce(fn, delay) &#123;</div><div class="line">    var timer = null;</div><div class="line">    return function () &#123;</div><div class="line">        var context = this,</div><div class="line">            args = arguments;</div><div class="line">        clearTimeout(timer);</div><div class="line">        timer = setTimeout(function () &#123;</div><div class="line">            fn.apply(context, args);</div><div class="line">        &#125;, delay);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="http://jinlong.github.io/2016/04/24/Debouncing-and-Throttling-Explained-Through-Examples/" target="_blank" rel="external">实例解析防抖动（Debouncing）和节流阀（Throttling）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;浅深拷贝的实现,原生extend实现,函数节流防抖......
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;一个简单浅复制的实现&quot;&gt;&lt;a href=&quot;#一个简单浅复制的实现&quot; class=&quot;headerlink&quot; title=&quot;一个简单浅复制的实现&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="JavaScript | 常用函数收集系列" scheme="https://double1000.github.io/blog/categories/JavaScript-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%94%B6%E9%9B%86%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JavaScript" scheme="https://double1000.github.io/blog/tags/JavaScript/"/>
    
      <category term="技巧" scheme="https://double1000.github.io/blog/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript | 常用函数/技巧 - Chapter 2</title>
    <link href="https://double1000.github.io/blog/2017/05/18/js-%E6%8A%80%E5%B7%A7%E6%94%B6%E9%9B%86-2/"/>
    <id>https://double1000.github.io/blog/2017/05/18/js-技巧收集-2/</id>
    <published>2017-05-18T00:44:09.000Z</published>
    <updated>2017-05-19T03:11:53.244Z</updated>
    
    <content type="html"><![CDATA[<pre><code>字数统计（中英文）,封装cookie组件,十六进制颜色值的随机生成,用户判断给定的对象是否是数组,判断检查数组中是否存在某个值,将字符串转换成URL编码,返回两个日期之间的时间间隔......
</code></pre><h4 id="用户判断给定的对象是否是数组"><a href="#用户判断给定的对象是否是数组" class="headerlink" title="用户判断给定的对象是否是数组"></a>用户判断给定的对象是否是数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function isArray(o)&#123;</div><div class="line">    return Object.prototype.toString.call(o)===&apos;[object Array]&apos;;</div><div class="line">&#125;</div><div class="line">// demo：</div><div class="line">isArray(&quot;str&quot;);  //false</div><div class="line">isArray([1,2]);  //true</div></pre></td></tr></table></figure>
<h4 id="判断检查数组中是否存在某个值"><a href="#判断检查数组中是否存在某个值" class="headerlink" title="判断检查数组中是否存在某个值"></a>判断检查数组中是否存在某个值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Array.prototype.inArray = function(e) &#123; </div><div class="line">    for(i=0;i &lt; this.length;i++)</div><div class="line">    &#123;</div><div class="line">        if(this[i] == e)</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line">// demo:</div><div class="line">[1,2].inArray(1);  //true</div></pre></td></tr></table></figure>
<h4 id="将字符串转换成URL编码"><a href="#将字符串转换成URL编码" class="headerlink" title="将字符串转换成URL编码"></a>将字符串转换成URL编码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var myString = &quot;hello all&quot;; </div><div class="line">var code = encodeURI(myString); //结果: &quot;hello%20all&quot; </div><div class="line">var str = decodeURI(code); //结果: &quot;hello all&quot;</div><div class="line">相应的还有: encodeURIComponent() decodeURIComponent()</div></pre></td></tr></table></figure>
<h4 id="十六进制颜色值的随机生成"><a href="#十六进制颜色值的随机生成" class="headerlink" title="十六进制颜色值的随机生成"></a>十六进制颜色值的随机生成</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function randomColor()&#123;</div><div class="line"> var arrHex=[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;],</div><div class="line">     strHex=&quot;#&quot;,</div><div class="line">     index;</div><div class="line">     for(var i=0;i&lt;6;i++)&#123;</div><div class="line">      index=Math.floor(Math.random()*14);</div><div class="line">      strHex+=arrHex[index];</div><div class="line">     &#125;</div><div class="line"> return strHex;</div><div class="line">&#125;</div><div class="line">console.log(randomColor());</div><div class="line"> </div><div class="line">function getRandomColor()&#123;</div><div class="line">    return &quot;#&quot;+(&quot;00000&quot;+((Math.random()*16777215+0.5)&gt;&gt;0).toString(16)).slice(-6);</div><div class="line">&#125;</div><div class="line">console.log(getRandomColor());</div><div class="line"></div><div class="line">说明：</div><div class="line">1,16777215为16进制的颜色FFFFFF转成10进制的数字</div><div class="line">2，&gt;&gt;数字取整</div><div class="line">3，转成16进制不足6位的以0来补充</div></pre></td></tr></table></figure>
<h4 id="封装cookie组件"><a href="#封装cookie组件" class="headerlink" title="封装cookie组件"></a>封装cookie组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">var Cookie = &#123; </div><div class="line">    // 读取</div><div class="line">     read : function(name)&#123; </div><div class="line">        var cookieStr = &quot;; &quot;+document.cookie+&quot;; &quot;; </div><div class="line">        var index = cookieStr.indexOf(&quot;; &quot;+name+&quot;=&quot;); </div><div class="line">        if (index!=-1)&#123; </div><div class="line">            var s = cookieStr.substring(index+name.length+3,cookieStr.length); </div><div class="line">            return unescape(s.substring(0, s.indexOf(&quot;; &quot;))); </div><div class="line">        &#125;else&#123; </div><div class="line">            return null; </div><div class="line">        &#125; </div><div class="line">    &#125;, </div><div class="line">    // 设置</div><div class="line">     set : function(name,value,expires)&#123; </div><div class="line">        var expDays = expires*24*60*60*1000; </div><div class="line">        var expDate = new Date(); </div><div class="line">        expDate.setTime(expDate.getTime()+expDays); </div><div class="line">        var expString = expires ? &quot;expires=&quot;+expDate.toGMTString() : &quot;&quot;; </div><div class="line">        var pathString = &quot;;path=/&quot;; </div><div class="line">        document.cookie = name + &quot;=&quot; + escape(value) + expString + pathString; </div><div class="line">    &#125;, </div><div class="line">    // 删除</div><div class="line">     del : function(name)&#123; </div><div class="line">        var exp = new Date(new Date().getTime()-1); </div><div class="line">        var s=this.read(name); </div><div class="line">        if(s!=null) &#123;</div><div class="line">            document.cookie= name + &quot;=&quot;+s+&quot;expires=&quot;+exp.toGMTString()+&quot;;path=/&quot;</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;;</div><div class="line">// demo:</div><div class="line">Cookie.set(&quot;xuanfengge&quot;, &quot;www.xuanfengge.com&quot;, 7);</div><div class="line">alert(Cookie.read(&quot;xuanfengge&quot;));</div><div class="line">Cookie.del(&quot;xuanfengge&quot;);</div></pre></td></tr></table></figure>
<h4 id="字数统计（中英文）"><a href="#字数统计（中英文）" class="headerlink" title="字数统计（中英文）"></a>字数统计（中英文）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function fucCheckLength(strTemp)&#123;</div><div class="line">    var i,sum;</div><div class="line">    sum=0;</div><div class="line">    for(i=0;i&lt;strTemp.length;i++)&#123;</div><div class="line">        if ((strTemp.charCodeAt(i)&gt;=0) &amp;&amp; (strTemp.charCodeAt(i)&lt;=255))&#123;</div><div class="line">            sum=sum+1;</div><div class="line">        &#125;else&#123;</div><div class="line">            sum=sum+2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return sum;</div><div class="line">&#125;</div><div class="line">// demo:</div><div class="line">fucCheckLength(&quot;qwe&quot;);        //3</div><div class="line">fucCheckLength(&quot;轩枫&quot;);        //4</div></pre></td></tr></table></figure>
<h4 id="返回两个日期之间的时间间隔"><a href="#返回两个日期之间的时间间隔" class="headerlink" title="返回两个日期之间的时间间隔"></a>返回两个日期之间的时间间隔</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function dateDiff(date1,date2) &#123;</div><div class="line">    var year,month,date,day1,day2;</div><div class="line">    var reg = /^(\d&#123;4&#125;)([-\/\.])(\d&#123;2&#125;)\2(\d&#123;2&#125;)$/;</div><div class="line"> </div><div class="line">    reg.test(date1);</div><div class="line">    year  = RegExp.$1.parseInt();</div><div class="line">    month = RegExp.$3.parseInt() - 1;</div><div class="line">    date  = RegExp.$4.parseInt();</div><div class="line">    day1 = new Date(year,month,date);</div><div class="line"> </div><div class="line">    reg.test(date2);</div><div class="line">    year  = RegExp.$1.parseInt();</div><div class="line">    month = RegExp.$3.parseInt() - 1;</div><div class="line">    date  = RegExp.$4.parseInt();</div><div class="line">    day2 = new Date(year,month,date);</div><div class="line"> </div><div class="line">    return (day1.getTime() - day2.getTime()) / 86400000;</div><div class="line">&#125;</div><div class="line">// demo:</div><div class="line">// 用以前，先用isDate()判断一下是否合法日期</div><div class="line">// 注意：这个函数的reg和isDate()里的reg小you不同</div><div class="line">// 以天为单位(date1-date2=?),可以用来比较2个日期大小</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;字数统计（中英文）,封装cookie组件,十六进制颜色值的随机生成,用户判断给定的对象是否是数组,判断检查数组中是否存在某个值,将字符串转换成URL编码,返回两个日期之间的时间间隔......
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;用户判断给定的对象是否
    
    </summary>
    
      <category term="JavaScript | 常用函数收集系列" scheme="https://double1000.github.io/blog/categories/JavaScript-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%94%B6%E9%9B%86%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JavaScript" scheme="https://double1000.github.io/blog/tags/JavaScript/"/>
    
      <category term="技巧" scheme="https://double1000.github.io/blog/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>web | 前端博客/资源收集</title>
    <link href="https://double1000.github.io/blog/2017/04/18/web-%E5%89%8D%E7%AB%AF%E5%8D%9A%E5%AE%A2-%E8%B5%84%E6%BA%90%E6%94%B6%E9%9B%86/"/>
    <id>https://double1000.github.io/blog/2017/04/18/web-前端博客-资源收集/</id>
    <published>2017-04-18T11:26:44.000Z</published>
    <updated>2017-05-19T01:21:40.497Z</updated>
    
    <content type="html"><![CDATA[<p>高质量值得长期关注的博客/社区,一些常用到的问题解决方案,学习网站,其它杂类/ ……</p>
<h3 id="高质量值得长期关注的博客-社区"><a href="#高质量值得长期关注的博客-社区" class="headerlink" title="高质量值得长期关注的博客/社区"></a>高质量值得长期关注的博客/社区</h3><hr>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="external">高质量的入门指南 - JavaScript|MDN</a><br><a href="http://www.jb51.net/onlineread/JavaScript-Garden-CN/#array.constructor" target="_blank" rel="external">JavaScript|秘密花园 - 一些古怪用法的文档</a><br><a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">廖雪峰个人网站 - 一个不错的学习博客</a><br><a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="external">阮一峰的个人网站 - 知其然,知其所以然</a><br><a href="http://www.zhangxinxu.com/" target="_blank" rel="external">张鑫旭的个人主页 - 深度广度都可以有</a><br><a href="https://fequan.com/" target="_blank" rel="external">前端圈 - 打造专业的前端技术会议</a><br><a href="http://yanhaijing.com/" target="_blank" rel="external">颜海镜 - 专注Web前端</a><br><a href="http://caibaojian.com/" target="_blank" rel="external">网站|前端开发博客</a><br><a href="http://www.w3cplus.com/" target="_blank" rel="external">网站|w3cplus - 推荐/一个不错的社区</a><br><a href="https://juejin.im/" target="_blank" rel="external">网站|掘金 - 推荐/高质量的社区</a></p>
<h3 id="一些常用到的问题解决方案"><a href="#一些常用到的问题解决方案" class="headerlink" title="一些常用到的问题解决方案"></a>一些常用到的问题解决方案</h3><hr>
<p><a href="http://www.w3cplus.com/solution/index/index.html" target="_blank" rel="external">一些怪异行为-css解决方案</a><br><a href="http://browserhacks.com/" target="_blank" rel="external">浏览器一些hack大全</a></p>
<h3 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h3><hr>
<p><a href="http://www.imooc.com/" target="_blank" rel="external">慕课网 | 最喜欢的学习网站</a><br><a href="http://thecodeplayer.com/" target="_blank" rel="external">Learn HTML5, CSS3, Javascript | 推荐</a><br><a href="http://codepen.io/" target="_blank" rel="external">codepen|代码笔 - 推荐</a><br><a href="http://www.jikexueyuan.com/" target="_blank" rel="external">极客学院 | 基础/一般推荐</a><br><a href="http://study.163.com/" target="_blank" rel="external">网易云课堂 | 各种类型/值得常关注</a><br><a href="https://open.163.com/" target="_blank" rel="external">网易公开课 | 各种TED/演讲</a><br><a href="http://www.gogoup.com/" target="_blank" rel="external">高高手 | 一个高质量的设计PS网站</a><br><a href="http://www.xsteach.com/" target="_blank" rel="external">刑帅教育 | 一般推荐/杂</a><br><a href="https://jirengu.com/" target="_blank" rel="external">饥人谷 | 一般推荐</a></p>
<h3 id="其它杂类"><a href="#其它杂类" class="headerlink" title="其它杂类/"></a>其它杂类/</h3><hr>
<p><a href="http://www.108js.com/" target="_blank" rel="external">JavaScript|探索者 - 不推荐,乱七八糟的一些小例子</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高质量值得长期关注的博客/社区,一些常用到的问题解决方案,学习网站,其它杂类/ ……&lt;/p&gt;
&lt;h3 id=&quot;高质量值得长期关注的博客-社区&quot;&gt;&lt;a href=&quot;#高质量值得长期关注的博客-社区&quot; class=&quot;headerlink&quot; title=&quot;高质量值得长期关注的博客
    
    </summary>
    
    
      <category term="web" scheme="https://double1000.github.io/blog/tags/web/"/>
    
      <category term="博客" scheme="https://double1000.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>web | 前端相关术语</title>
    <link href="https://double1000.github.io/blog/2017/04/12/web-%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E5%90%8D%E5%AD%97%E4%BB%A5%E5%8F%8A%E8%A7%A3%E9%87%8A/"/>
    <id>https://double1000.github.io/blog/2017/04/12/web-前端相关名字以及解释/</id>
    <published>2017-04-12T04:58:11.000Z</published>
    <updated>2017-05-19T01:22:39.869Z</updated>
    
    <content type="html"><![CDATA[<p>组件化,同步跟异步,阻塞与非阻塞…..</p>
<ul>
<li>组件化<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">组件化就是基于可重用的目的，将一个大的软件系统按照分离关注点的形式，</div><div class="line">拆分成多个独立的组件，主要目的就是减少耦合。</div><div class="line">一个独立的组件可以是一个软件包、web服务、web资源或者是封装了一些函数的模块。</div><div class="line">这样，独立出来的组件可以单独维护和升级而不会影响到其他的组件。</div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://www.zhihu.com/question/29735633" target="_blank" rel="external">知乎:什么叫组件化开发</a></p>
<ul>
<li>模块化<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">模块化的目的在于将一个程序按照其功能做拆分，分成相互独立的模块，</div><div class="line">便于每个模块只包含与其功能相关的内容，模块之间通过接口调用。</div><div class="line">将一个大的系统模块化之后，每个模块都可以被高度复用。</div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://www.zhihu.com/question/37649318" target="_blank" rel="external">知乎:前端开发的模块化和组件化的定义，以及两者的关系</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">模块化的目的是为了重用，模块化后可以方便重复使用和插拨到不同的平台，不同的业务逻辑过程中。</div><div class="line">组件化的目的是为了解耦，把系统拆分成多个组件，分离组件边界和责任，便于独立升级和维护。</div></pre></td></tr></table></figure>
<ul>
<li>同步跟异步<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">同步是阻塞模式，异步是非阻塞模式。 </div><div class="line">同步是指两个线程的运行是相关的，其中一个线程要阻塞等待另外一个线程的运行。</div><div class="line">异步的意思是两个线程毫无相关，自己运行自己的。 </div><div class="line"></div><div class="line">同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。 </div><div class="line">异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://segmentfault.com/a/1190000004322358#articleHeader1" target="_blank" rel="external">彻底理解同步、异步和事件循环(Event Loop)</a><br><a href="http://blog.csdn.net/u013063153/article/details/52457307" target="_blank" rel="external">深入理解JavaScript编程中的同步与异步机制</a></p>
<ul>
<li>阻塞与非阻塞<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。</div><div class="line">阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</div><div class="line">非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</div><div class="line"></div><div class="line">示例：</div><div class="line">以打电话让书店老板查找某本书为例来讲：</div><div class="line">同步通信机制：老板说，“你稍等，我查下”，然后查好后（可能会<span class="number">5</span>秒或者<span class="number">1</span>天）告诉你结果（返回结果）。</div><div class="line">异步通信机制：老板说，“我查好后打电话你”，然后直接挂电话（无返回结果）。查好后打电话你（“回电”这种方式回调/通知你）。</div><div class="line">阻塞式调用：打电话给老板时，你会一直把自己“挂起”，直到结果返回。</div><div class="line">非阻塞式调用：打电话给老板时，不管老板有没有告诉你，你自己先一边玩了，但可能会每过几分钟跟老板check一下有没有返回结果。</div><div class="line"></div><div class="line">总结：阻塞与非阻塞 与 是否同步异步无关（跟老板通过什么方式回答你无关）。</div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://github.com/creeperyang/blog/issues/15" target="_blank" rel="external">编程资源（概念解释/优秀博文/其它)</a><br><a href="https://www.zhihu.com/question/19732473/answer/20851256" target="_blank" rel="external">知乎:怎样理解阻塞非阻塞与同步异步的区别？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组件化,同步跟异步,阻塞与非阻塞…..&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组件化&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;lin
    
    </summary>
    
    
      <category term="协议/标准" scheme="https://double1000.github.io/blog/tags/%E5%8D%8F%E8%AE%AE-%E6%A0%87%E5%87%86/"/>
    
      <category term="WEB" scheme="https://double1000.github.io/blog/tags/WEB/"/>
    
      <category term="[object Object]" scheme="https://double1000.github.io/blog/tags/object-Object/"/>
    
      <category term="寄蜉蝣于天地,渺沧海之一粟" scheme="https://double1000.github.io/blog/tags/%E5%AF%84%E8%9C%89%E8%9D%A3%E4%BA%8E%E5%A4%A9%E5%9C%B0-%E6%B8%BA%E6%B2%A7%E6%B5%B7%E4%B9%8B%E4%B8%80%E7%B2%9F/"/>
    
  </entry>
  
  <entry>
    <title>HTTP | 前端开发工程师应该知道的HTTP协议知识</title>
    <link href="https://double1000.github.io/blog/2017/04/12/http-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84http%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86/"/>
    <id>https://double1000.github.io/blog/2017/04/12/http-前端开发工程师应该知道的http协议知识/</id>
    <published>2017-04-12T00:40:31.000Z</published>
    <updated>2017-04-12T04:50:59.758Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h3><p><a href="https://www.wikiwand.com/zh/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">维基百科</a><br><a href="http://xiaotank.blog.51cto.com/2461521/1191420" target="_blank" rel="external">HTTP详解</a><br><a href="http://www.imooc.com/article/14281" target="_blank" rel="external">从访问网页简单理解互联网数据交换的整个过程</a><br><a href="http://www.imooc.com/article/14397" target="_blank" rel="external">前端开发工程师应该知道的http协议知识</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考来源&quot;&gt;&lt;a href=&quot;#参考来源&quot; class=&quot;headerlink&quot; title=&quot;参考来源&quot;&gt;&lt;/a&gt;参考来源&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.wikiwand.com/zh/%E8%B6%85%E6%96%87%E6%9C%
    
    </summary>
    
      <category term="寄蜉蝣于天地,渺沧海之一粟" scheme="https://double1000.github.io/blog/categories/%E5%AF%84%E8%9C%89%E8%9D%A3%E4%BA%8E%E5%A4%A9%E5%9C%B0-%E6%B8%BA%E6%B2%A7%E6%B5%B7%E4%B9%8B%E4%B8%80%E7%B2%9F/"/>
    
    
      <category term="http" scheme="https://double1000.github.io/blog/tags/http/"/>
    
      <category term="协议/标准" scheme="https://double1000.github.io/blog/tags/%E5%8D%8F%E8%AE%AE-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Notes | 作用域和闭包</title>
    <link href="https://double1000.github.io/blog/2017/04/09/javascript-notes-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/"/>
    <id>https://double1000.github.io/blog/2017/04/09/javascript-notes-作用域和闭包/</id>
    <published>2017-04-09T11:58:50.000Z</published>
    <updated>2017-04-12T01:06:20.489Z</updated>
    
    <content type="html"><![CDATA[<p><img src="1.jpg"></p>
<h1 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h1><p>作用域和闭包是 JavaScript 最重要的概念之一，想要进一步学习 JavaScript，就必须理解 JavaScript 作用域和闭包的工作原理。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在 JavaScript 中，变量的作用域有全局作用域和局部作用域两种。</p>
<h3 id="全局作用域（Global-Scope）"><a href="#全局作用域（Global-Scope）" class="headerlink" title="全局作用域（Global Scope）"></a>全局作用域（Global Scope）</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下三种情形拥有全局作用域：</p>
<p>1.最外层函数和在最外层函数外面定义的变量拥有全局作用域，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> global = <span class="string">"global"</span>;     <span class="comment">// 显式声明一个全局变量</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> local = <span class="string">"local"</span>;   <span class="comment">// 显式声明一个局部变量</span></div><div class="line">    <span class="keyword">return</span> global;         <span class="comment">// 返回全局变量的值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(global);       <span class="comment">// "global"</span></div><div class="line"><span class="built_in">console</span>.log(checkscope()); <span class="comment">// "global"</span></div><div class="line"><span class="built_in">console</span>.log(local);        <span class="comment">// error: local is not defined.</span></div></pre></td></tr></table></figure>
<p>上面代码中，<code>global</code> 是全局变量，不管是在 <code>checkscope()</code> 函数内部还是外部，都能访问到全局变量 <code>global</code>。</p>
<p>2.所有末定义直接赋值的变量自动声明为拥有全局作用域，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> local = <span class="string">"local"</span>; <span class="comment">// 显式声明一个局部变量</span></div><div class="line">    global = <span class="string">"global"</span>;   <span class="comment">// 隐式声明一个全局变量(不好的写法)</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(global);     <span class="comment">// "global"</span></div><div class="line"><span class="built_in">console</span>.log(local);      <span class="comment">// error: local is not defined.</span></div></pre></td></tr></table></figure>
<p>上面代码中，变量 <code>global</code> 未用 <code>var</code> 关键字定义就直接赋值，所以隐式的创建了全局变量 <code>global</code>，但这种写法容易造成误解，应尽量避免这种写法。</p>
<p>3.所有 <code>window</code> 对象的属性拥有全局作用域</p>
<p>一般情况下，<code>window</code> 对象的内置属性都拥有全局作用域，例如 <code>window.name</code>、<code>window.location</code>、<code>window.top</code> 等等。</p>
<h3 id="局部作用域（Local-Scope）"><a href="#局部作用域（Local-Scope）" class="headerlink" title="局部作用域（Local Scope）"></a>局部作用域（Local Scope）</h3><p>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到。最常见的是在函数体内定义的变量，只能在函数体内使用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> local = <span class="string">"local"</span>;   <span class="comment">// 显式声明一个局部变量</span></div><div class="line">    <span class="keyword">return</span> local;         <span class="comment">// 返回全局变量的值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(checkscope()); <span class="comment">// "local"</span></div><div class="line"><span class="built_in">console</span>.log(local);        <span class="comment">// error: local is not defined.</span></div></pre></td></tr></table></figure>
<p>上面代码中，在函数体内定义了变量 <code>local</code>，在函数体内是可以访问了，在函数外访问就报错了。</p>
<h3 id="全局和局部作用域的关系"><a href="#全局和局部作用域的关系" class="headerlink" title="全局和局部作用域的关系"></a>全局和局部作用域的关系</h3><p>在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所遮盖。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;      <span class="comment">// 声明一个全局变量</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local"</span>;   <span class="comment">// 声明一个同名的局部变量</span></div><div class="line">    <span class="keyword">return</span> scope;          <span class="comment">// 返回局部变量的值，而不是全局变量的值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(checkscope()); <span class="comment">// "local"</span></div></pre></td></tr></table></figure>
<p>尽管在全局作用域编写代码时可以不写 <code>var</code> 语句，但声明局部变量时则必须使用 <code>var</code> 语句。思考一下如果不这样做会怎样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">scope = <span class="string">"global"</span>;           <span class="comment">// 声明一个全局变量，甚至不用 var 来声明</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    scope = <span class="string">"local"</span>;        <span class="comment">// 糟糕！我们刚修改了全局变量</span></div><div class="line">    myscope = <span class="string">"local"</span>;      <span class="comment">// 这里显式地声明了一个新的全局变量</span></div><div class="line">    <span class="keyword">return</span> [scope, myscope];<span class="comment">// 返回两个值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(checkscope2()); <span class="comment">// ["local", "local"]，产生了副作用</span></div><div class="line"><span class="built_in">console</span>.log(scope);         <span class="comment">// "local"，全局变量修改了</span></div><div class="line"><span class="built_in">console</span>.log(myscope);       <span class="comment">// "local"，全局命名空间搞乱了</span></div></pre></td></tr></table></figure>
<p>函数定义是可以嵌套的。由于每个函数都有它自己的作用域，因此会出现几个局部作用域嵌套的情况，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;         <span class="comment">// 全局变量</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;      <span class="comment">//局部变量 </span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">nested</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> scope = <span class="string">"nested scope"</span>; <span class="comment">// 嵌套作用域内的局部变量</span></div><div class="line">        <span class="keyword">return</span> scope;               <span class="comment">// 返回当前作用域内的值</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> nested();</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(checkscope());          <span class="comment">// "nested scope"</span></div></pre></td></tr></table></figure>
<h3 id="函数作用域和声明提前"><a href="#函数作用域和声明提前" class="headerlink" title="函数作用域和声明提前"></a>函数作用域和声明提前</h3><p>在一些类似 C 语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，我们称为块级作用域（block scope），而 JavaScript 中没有块级作用域。JavaScript 取而代之地使用了函数作用域（function scope），变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。</p>
<p>在如下所示的代码中，在不同位置定义了变量 <code>i</code>、<code>j</code> 和 <code>k</code>，它们都在同一个作用域内，这三个变量在函数体内均是有定义的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>; <span class="comment">// i在整个函数体内均是有定义的</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> o == <span class="string">"object"</span>) &#123;</div><div class="line">        <span class="keyword">var</span> j = <span class="number">0</span>; <span class="comment">// j在函数体内是有定义的，不仅仅是在这个代码段内</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123; <span class="comment">// k在函数体内是有定义的，不仅仅是在循环内</span></div><div class="line">            <span class="built_in">console</span>.log(k); <span class="comment">// 输出数字0~9</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.log(k); <span class="comment">// k已经定义了，输出10</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(j); <span class="comment">// j已经定义了，但可能没有初始化</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JavaScript 的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至已经可用。JavaScript 的这个特性被非正式地称为声明提前（hoisting），即 JavaScript 函数里声明的所有变量（但不涉及赋值）都被「提前」至函数体的顶部，看一下如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(scope);  <span class="comment">// 输出"undefined"，而不是"global"</span></div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local"</span>; <span class="comment">// 变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的</span></div><div class="line">    <span class="built_in">console</span>.log(scope);  <span class="comment">// 输出"local"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可能会误以为函数中的第一行会输出 <code>&quot;global&quot;</code>，因为代码还没有执行到 <code>var</code> 语句声明局部变量的地方。其实不然，由于函数作用域的特性，局部变量在整个函数体始终是有定义的，也就是说，在函数体内局部变量遮盖了同名全局变量。尽管如此，只有在程序执行到 <code>var</code> 语句的时候，局部变量才会被真正赋值。因此，上述过程等价于：将函数内的变量声明“提前”至函数体顶部，同时变量初始化留在原来的位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope;          <span class="comment">// 在函数顶部声明了局部变量</span></div><div class="line">    <span class="built_in">console</span>.log(scope); <span class="comment">// 变量存在，但其值是"undefined"</span></div><div class="line">    scope = <span class="string">"local"</span>;    <span class="comment">// 这里将其初始化并赋值</span></div><div class="line">    <span class="built_in">console</span>.log(scope); <span class="comment">// 这里它具有了我们所期望的值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在具有块级作用域的编程语言中，在狭小的作用域里让变量声明和使用变量的代码尽可能靠近彼此，通常来讲，这是一个非常不错的编程习惯。由于 JavaScript 没有块级作用域，因此一些程序员特意将变量声明放在函数体顶部，而不是将声明靠近放在使用变量之处。这种做法使得他们的源代码非常清晰地反映了真实的变量作用域。</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其<strong>活动对象</strong>（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 <code>arguments</code> 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。</p>
<p>请看下面的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (color === <span class="string">"blue"</span>)&#123;</div><div class="line">        color = <span class="string">"red"</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        color = <span class="string">"blue"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(changeColor());</div></pre></td></tr></table></figure>
<p>在这个简单的例子中，函数 <code>changeColor()</code> 的作用域链包含两个对象：它自己的变量对象（其中定义着 <code>arguments</code> 对象）和全局环境的变量对象。可以在函数内部访问变量 <code>color</code>，就是因为可以在这个作用域链中找到它。</p>
<p>此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面这个例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> tempColor = anotherColor;</div><div class="line">        anotherColor = color;</div><div class="line">        color = tempColor;</div><div class="line"></div><div class="line">        <span class="comment">// 这里可以访问color、anotherColor和tempColor</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这里可以访问color和anotherColor，但不能访问tempColor</span></div><div class="line">    swapColors();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这里只能访问color</span></div><div class="line">changeColor();</div></pre></td></tr></table></figure>
<p>以上代码共涉及3个执行环境：全局环境、<code>changeColor()</code> 的局部环境和 <code>swapColors()</code> 的局部环境。全局环境中有一个变量 <code>color</code> 和一个函数 <code>changeColor()</code>。<code>changeColor()</code> 的局部环境中有一个名为 <code>anotherColor</code> 的变量和一个名为 <code>swapColors()</code> 的函数，但它也可以访问全局环境中的变量 <code>color</code>。<code>swapColors()</code> 的局部环境中有一个变量 <code>tempColor</code>，该变量只能在这个环境中访问到。无论全局环境还是 <code>changeColor()</code> 的局部环境都无权访问 <code>tempColor</code>。然而，在 <code>swapColors()</code> 内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。下图形象地展示了前面这个例子的作用域链。</p>
<p><img src="http://qiniu.shijiajie.com/blog/javascript-lesson/2.41.jpg" alt=""></p>
<p>上图中的矩形表示特定的执行环境。其中，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。对于这个例子中的 <code>swapColors()</code> 而言，其作用域链中包含3个对象：<code>swapColors()</code> 的变量对象、<code>changeColor()</code> 的变量对象和全局变量对象。<code>swapColors()</code> 的局部环境开始时会先在自己的变量对象中搜索变量和函数名，如果搜索不到则再搜索上一级作用域链。<code>changeColor()</code> 的作用域链中只包含两个对象：它自己的变量对象和全局变量对象。这也就是说，它不能访问 <code>swapColors()</code> 的环境。函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>MDN 对闭包的定义：</p>
<blockquote>
<p>闭包是指那些能够访问独立（自由）变量的函数（变量在本地使用，但定义在一个封闭的作用域中）。换句话说，这些函数可以「记忆」它被创建时候的环境。</p>
</blockquote>
<p>《JavaScript 权威指南(第6版)》对闭包的定义：</p>
<blockquote>
<p>函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为闭包。</p>
</blockquote>
<p>《JavaScript 高级程序设计(第3版)》对闭包的定义：</p>
<blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>
</blockquote>
<p>上面这些定义都比较晦涩难懂，<a href="http://www.ruanyifeng.com/" target="_blank" rel="external">阮一峰</a>的解释稍微好理解一些：</p>
<blockquote>
<p>由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成定义在一个函数内部的函数。</p>
</blockquote>
<h3 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h3><p>闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量（作用域链），另一个就是让这些变量的值始终保持在内存中。怎么来理解这句话呢？请看下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;　　　</div><div class="line">    <span class="keyword">var</span> n = <span class="number">1</span>;</div><div class="line"></div><div class="line">    add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        n += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(n);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fun2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = fun();　　</div><div class="line">result(); <span class="comment">// 1</span></div><div class="line">add();</div><div class="line">result(); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>在这段代码中，<code>result</code> 实际上就是函数 <code>fun2</code>。它一共运行了两次，第一次的值是 <code>1</code>，第二次的值是 <code>2</code>。这证明了，函数 <code>fun</code> 中的局部变量 <code>n</code> 一直保存在内存中，并没有在 <code>fun</code> 调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于 <code>fun</code> 是 <code>fun2</code> 的父函数，而 <code>fun2</code> 被赋给了一个全局变量，这导致 <code>fun2</code> 始终在内存中，而 <code>fun2</code> 的存在依赖于 <code>fun</code>，因此 <code>fun</code> 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<p>这段代码中另一个值得注意的地方，就是 <code>add = function() { n += 1 }</code> 这一行。首先，变量 <code>add</code> 前面没有使用 <code>var</code> 关键字，因此 <code>add</code> 是一个全局变量，而不是局部变量。其次，<code>add</code> 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，和 <code>fun2</code> 处于同一作用域，所以 <code>add</code> 相当于是一个 <code>setter</code>，可以在函数外部对函数内部的局部变量进行操作。</p>
<h3 id="计数器的困境"><a href="#计数器的困境" class="headerlink" title="计数器的困境"></a>计数器的困境</h3><p>我们再来看一个经典例子「计数器的困境」，假设你想统计一些数值，且该计数器在所有函数中都是可用的。你可以定义一个全局变量 <code>counter</code> 当做计数器，再定义一个 <code>add()</code> 函数来设置计数器递增。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> counter += <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="comment">// 计数器现在为 3</span></div></pre></td></tr></table></figure>
<p>计数器数值在执行 <code>add()</code> 函数时发生变化。但问题来了，页面上的任何脚本都能改变计数器 <code>counter</code>，即便没有调用 <code>add()</code> 函数。如果我们将计数器 <code>counter</code> 定义在 <code>add()</code> 函数内部，就不会被外部脚本随意修改到计数器的值了。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> counter += <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="comment">// 本意是想输出 3, 但事与愿违，输出的都是 1</span></div></pre></td></tr></table></figure>
<p>因为每次调用 <code>add()</code> 函数，计数器都会被重置为 0，输出的都是 1，这并不是我们想要的结果。闭包正好可以解决这个问题，我们在 <code>add()</code> 函数内部，再定义一个 <code>plus()</code> 内嵌函数（闭包），内嵌函数 <code>plus()</code> 可以访问父函数的 <code>counter</code> 变量。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> plus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;counter += <span class="number">1</span>;&#125;</div><div class="line">    plus();</div><div class="line">    <span class="keyword">return</span> counter; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，只要我们能在外部访问 <code>plus()</code> 函数，并且确保 <code>counter = 0</code> 只执行一次，就能解决计数器的困境。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> plus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> counter += <span class="number">1</span>;&#125;</div><div class="line">    <span class="keyword">return</span> plus;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> puls2 = add();</div><div class="line"><span class="built_in">console</span>.log(puls2());</div><div class="line"><span class="built_in">console</span>.log(puls2());</div><div class="line"><span class="built_in">console</span>.log(puls2());</div><div class="line"><span class="comment">// 计数器为 3</span></div></pre></td></tr></table></figure>
<p>计数器 <code>counter</code> 受 <code>add()</code> 函数的作用域保护，只能通过 <code>puls2</code> 方法修改。</p>
<h3 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h3><ul>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除或设置为 <code>null</code>，断开变量和内存的联系。</li>
<li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（public method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>
</ul>
<p>JavaScript 闭包是一种强大的语言特性。通过使用这个语言特性来隐藏变量，可以避免覆盖其他地方使用的同名变量，理解闭包有助于编写出更有效也更简洁的代码。</p>
<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a><code>this</code> 关键字</h2><p>谈到作用域和闭包就不得不说 <code>this</code> 关键字，虽然它们之间关联不大，但是它们一起使用却容易让人产生疑惑。下面列出了使用 <code>this</code> 的大部分场景，带大家一探究竟。</p>
<p><code>this</code> 是 JavaScript 的关键字，指函数执行时的上下文，跟函数定义时的上下文无关。随着函数使用场合的不同，<code>this</code> 的值会发生变化。但是有一个总的原则，那就是 <code>this</code> 指代的是调用函数的那个对象。</p>
<h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>在全局上下文中，也就是在任何函数体外部，<code>this</code> 指代全局对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在浏览器中，this 指代全局对象 window</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>在函数上下文中，也就是在任何函数体内部，<code>this</code> 指代调用函数的那个对象。</p>
<h4 id="函数调用中的-this"><a href="#函数调用中的-this" class="headerlink" title="函数调用中的 this"></a>函数调用中的 <code>this</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(f1() === <span class="built_in">window</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>如上代码所示，直接定义一个函数 <code>f1()</code>，相当于为 <code>window</code> 对象定义了一个属性。直接执行函数 <code>f1()</code>，相当于执行 <code>window.f1()</code>。所以函数 <code>f1()</code> 中的 <code>this</code> 指代调用函数的那个对象，也就是 <code>window</code> 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>; <span class="comment">// 这里是严格模式</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(f2() === <span class="literal">undefined</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>如上代码所示，在「严格模式」下，禁止 <code>this</code> 关键字指向全局对象（在浏览器环境中也就是 <code>window</code> 对象），<code>this</code> 的值将维持 <code>undefined</code> 状态。</p>
<h4 id="对象方法中的-this"><a href="#对象方法中的-this" class="headerlink" title="对象方法中的 this"></a>对象方法中的 <code>this</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"stone"</span>,</div><div class="line">    <span class="attr">f</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// "stone"</span></div></pre></td></tr></table></figure>
<p>如上代码所示，对象 <code>o</code> 中包含一个属性 <code>name</code> 和一个方法 <code>f()</code>。当我们执行 <code>o.f()</code> 时，方法 <code>f()</code> 中的 <code>this</code> 指代调用函数的那个对象，也就是对象 <code>o</code>，所以 <code>this.name</code> 也就是 <code>o.name</code>。</p>
<p>注意，在何处定义函数完全不会影响到 <code>this</code> 的行为，我们也可以首先定义函数，然后再将其附属到 <code>o.f</code>。这样做 <code>this</code> 的行为也一致。如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">name</span>: <span class="string">"stone"</span> &#125;;</div><div class="line">o.f = fun;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// "stone"</span></div></pre></td></tr></table></figure>
<p>类似的，<code>this</code> 的绑定只受最靠近的成员引用的影响。在下面的这个例子中，我们把一个方法 <code>g()</code> 当作对象 <code>o.b</code> 的函数调用。在这次执行期间，函数中的 <code>this</code> 将指向 <code>o.b</code>。事实上，这与对象本身的成员没有多大关系，最靠近的引用才是最重要的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">o.b = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"sophie"</span></div><div class="line">    g: fun,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.b.g()); <span class="comment">// "sophie"</span></div></pre></td></tr></table></figure>
<h4 id="eval-方法中的-this"><a href="#eval-方法中的-this" class="headerlink" title="eval() 方法中的 this"></a><code>eval()</code> 方法中的 <code>this</code></h4><p><code>eval()</code> 方法可以将字符串转换为 JavaScript 代码，使用 <code>eval()</code> 方法时，<code>this</code> 指向哪里呢？答案很简单，看谁在调用 <code>eval()</code> 方法，调用者的执行环境中的 <code>this</code> 就被 <code>eval()</code> 方法继承下来了。如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局上下文</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">"this"</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(f1() === <span class="built_in">window</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 函数上下文</span></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"stone"</span>,</div><div class="line">    <span class="attr">f</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">"this.name"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// "stone"</span></div></pre></td></tr></table></figure>
<h4 id="call-和-apply-方法中的-this"><a href="#call-和-apply-方法中的-this" class="headerlink" title="call() 和 apply() 方法中的 this"></a><code>call()</code> 和 <code>apply()</code> 方法中的 <code>this</code></h4><p><code>call()</code> 和 <code>apply()</code> 是函数对象的方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，<code>this</code> 指代的就是这两个方法的第一个参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">0</span>;　　</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;　　　　</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);　　</div><div class="line">&#125;　　</div><div class="line"><span class="keyword">var</span> o = &#123;&#125;;　　</div><div class="line">o.x = <span class="number">1</span>;</div><div class="line">o.m = f;　　</div><div class="line">o.m.apply(); <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p><code>call()</code> 和 <code>apply()</code> 的参数为空时，默认调用全局对象。因此，这时的运行结果为 <code>0</code>，证明 <code>this</code> 指的是全局对象。如果把最后一行代码修改为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">o.m.apply(o); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>运行结果就变成了 <code>1</code>，证明了这时 <code>this</code> 指代的是对象 <code>o</code>。</p>
<h4 id="bind-方法中的-this"><a href="#bind-方法中的-this" class="headerlink" title="bind() 方法中的 this"></a><code>bind()</code> 方法中的 <code>this</code></h4><p>ECMAScript 5 引入了 <code>Function.prototype.bind</code>。调用 <code>f.bind(someObject)</code> 会创建一个与 <code>f</code> 具有相同函数体和作用域的函数，但是在这个新函数中，<code>this</code> 将永久地被绑定到了 <code>bind</code> 的第一个参数，无论这个函数是如何被调用的。如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = f.bind(&#123;</div><div class="line">    <span class="attr">a</span>: <span class="string">"stone"</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// stone</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">28</span>,</div><div class="line">    <span class="attr">f</span>: f,</div><div class="line">    <span class="attr">g</span>: g</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(o.f(), o.g()); <span class="comment">// 28, stone</span></div></pre></td></tr></table></figure>
<h4 id="DOM-事件处理函数中的-this"><a href="#DOM-事件处理函数中的-this" class="headerlink" title="DOM 事件处理函数中的 this"></a>DOM 事件处理函数中的 <code>this</code></h4><p>一般来讲，当函数使用 <code>addEventListener</code>，被用作事件处理函数时，它的 <code>this</code> 指向触发事件的元素。如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</div><div class="line">        btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">this</span>.style.backgroundColor = <span class="string">"#A5D9F3"</span>;</div><div class="line">        &#125;, <span class="literal">false</span>);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>但在 IE 浏览器中，当函数使用 <code>attachEvent</code> ，被用作事件处理函数时，它的 <code>this</code> 却指向 <code>window</code>。如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</div><div class="line">        btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);  <span class="comment">// true</span></div><div class="line">        &#125;);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="内联事件处理函数中的-this"><a href="#内联事件处理函数中的-this" class="headerlink" title="内联事件处理函数中的 this"></a>内联事件处理函数中的 <code>this</code></h4><p>当代码被内联处理函数调用时，它的 <code>this</code> 指向监听器所在的 DOM 元素。如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert(this.tagName.toLowerCase());"</span>&gt;</span></div><div class="line">  Show this</div><div class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面的 <code>alert</code> 会显示 <code>button</code>，注意只有外层代码中的 <code>this</code> 是这样设置的。如果 <code>this</code> 被包含在匿名函数中，则又是另外一种情况了。如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert((function()&#123;return this&#125;)());"</span>&gt;</span></div><div class="line">  Show inner this</div><div class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在这种情况下，<code>this</code> 被包含在匿名函数中，相当于处于全局上下文中，所以它指向 <code>window</code> 对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;作用域和闭包&quot;&gt;&lt;a href=&quot;#作用域和闭包&quot; class=&quot;headerlink&quot; title=&quot;作用域和闭包&quot;&gt;&lt;/a&gt;作用域和闭包&lt;/h1&gt;&lt;p&gt;作用域和闭包是 JavaScript 最重要的概念之一，想
    
    </summary>
    
      <category term="寄蜉蝣于天地,渺沧海之一粟" scheme="https://double1000.github.io/blog/categories/%E5%AF%84%E8%9C%89%E8%9D%A3%E4%BA%8E%E5%A4%A9%E5%9C%B0-%E6%B8%BA%E6%B2%A7%E6%B5%B7%E4%B9%8B%E4%B8%80%E7%B2%9F/"/>
    
    
      <category term="JavaScript" scheme="https://double1000.github.io/blog/tags/JavaScript/"/>
    
      <category term="作用域" scheme="https://double1000.github.io/blog/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="闭包" scheme="https://double1000.github.io/blog/tags/%E9%97%AD%E5%8C%85/"/>
    
      <category term="Notes" scheme="https://double1000.github.io/blog/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>web | 开发流程环节/名词/规范</title>
    <link href="https://double1000.github.io/blog/2017/04/06/web-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E7%8E%AF%E8%8A%82/"/>
    <id>https://double1000.github.io/blog/2017/04/06/web-开发流程环节/</id>
    <published>2017-04-06T07:30:17.000Z</published>
    <updated>2017-04-12T04:54:55.554Z</updated>
    
    <content type="html"><![CDATA[<p><img src="1.jpg"></p>
<h4 id="一-相关名词解释"><a href="#一-相关名词解释" class="headerlink" title="一.相关名词解释"></a>一.相关名词解释</h4><ol>
<li>运维工程师 （代码部署工程服务） OP</li>
<li>产品经理  PM （ProductManager) 对产品负责</li>
<li>MRD 产出 市场需求文档 对产品复杂分析</li>
<li>UI UserInterface 界面视觉设计</li>
<li>UE UserExperience 用户体验设计</li>
<li>技术经理 PM (PojectManager)</li>
<li>项目管理员,对项目负责</li>
<li>前端开发 FE - FrontEnd developer engineer</li>
<li>后端开发 RD</li>
<li>测试 QA</li>
</ol>
<h4 id="二-WEB开发流程"><a href="#二-WEB开发流程" class="headerlink" title="二.WEB开发流程"></a>二.WEB开发流程</h4><h5 id="2-1-需求确定"><a href="#2-1-需求确定" class="headerlink" title="2-1. 需求确定"></a>2-1. 需求确定</h5><h5 id="2-2-分析与设计"><a href="#2-2-分析与设计" class="headerlink" title="2-2. 分析与设计"></a>2-2. 分析与设计</h5><h6 id="2-2-1-架构分析与设计"><a href="#2-2-1-架构分析与设计" class="headerlink" title="2-2.1. 架构分析与设计"></a>2-2.1. 架构分析与设计</h6><h6 id="2-2-2-业务逻辑分析"><a href="#2-2-2-业务逻辑分析" class="headerlink" title="2-2.2. 业务逻辑分析"></a>2-2.2. 业务逻辑分析</h6><h6 id="2-2-3-业务逻辑设计"><a href="#2-2-3-业务逻辑设计" class="headerlink" title="2-2.3. 业务逻辑设计"></a>2-2.3. 业务逻辑设计</h6><h6 id="2-2-4-界面设计"><a href="#2-2-4-界面设计" class="headerlink" title="2-2.4. 界面设计"></a>2-2.4. 界面设计</h6><h5 id="2-3-开发环境搭建"><a href="#2-3-开发环境搭建" class="headerlink" title="2-3. 开发环境搭建"></a>2-3. 开发环境搭建</h5><h5 id="2-4-开发-测试-开发-测试"><a href="#2-4-开发-测试-开发-测试" class="headerlink" title="2-4. 开发-测试-开发-测试"></a>2-4. 开发-测试-开发-测试</h5><h5 id="2-5-文档编纂"><a href="#2-5-文档编纂" class="headerlink" title="2-5. 文档编纂"></a>2-5. 文档编纂</h5><h4 id="三-WEB开发环节"><a href="#三-WEB开发环节" class="headerlink" title="三.WEB开发环节"></a>三.WEB开发环节</h4><ul>
<li><p>开发前</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">产品功能设计</div><div class="line">视觉 最终效果 （ 产品经理）</div><div class="line">视觉/交互设计 交互 操作流程（美工）</div></pre></td></tr></table></figure>
</li>
<li><p>开发中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">技术规划</div><div class="line">考虑产品需求是否合理</div><div class="line">产品代码是否可以复用</div><div class="line">复杂项目是否可以拆分  （技术经理）</div></pre></td></tr></table></figure>
</li>
<li><p>开发后</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">测试 （测试工程师QA 对网页代码进行 功能/性能测试）</div><div class="line">上线</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="四-WEB开发文档"><a href="#四-WEB开发文档" class="headerlink" title="四.WEB开发文档"></a>四.WEB开发文档</h4><h5 id="1-需求文档-MRD-描述项目功能需求"><a href="#1-需求文档-MRD-描述项目功能需求" class="headerlink" title="1.需求文档 MRD  描述项目功能需求"></a>1.需求文档 MRD  描述项目功能需求</h5><h5 id="2-项目开发文档-技术经理负责"><a href="#2-项目开发文档-技术经理负责" class="headerlink" title="2.项目开发文档 技术经理负责"></a>2.项目开发文档 技术经理负责</h5><ol>
<li>可行性确认</li>
<li>技术选型</li>
<li>开发/线上坏境规划</li>
<li>技术开发方案设计</li>
<li>团队协作方式</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;一-相关名词解释&quot;&gt;&lt;a href=&quot;#一-相关名词解释&quot; class=&quot;headerlink&quot; title=&quot;一.相关名词解释&quot;&gt;&lt;/a&gt;一.相关名词解释&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;运维工程师 （代码部署工程服务
    
    </summary>
    
      <category term="寄蜉蝣于天地,渺沧海之一粟" scheme="https://double1000.github.io/blog/categories/%E5%AF%84%E8%9C%89%E8%9D%A3%E4%BA%8E%E5%A4%A9%E5%9C%B0-%E6%B8%BA%E6%B2%A7%E6%B5%B7%E4%B9%8B%E4%B8%80%E7%B2%9F/"/>
    
    
      <category term="协议/标准" scheme="https://double1000.github.io/blog/tags/%E5%8D%8F%E8%AE%AE-%E6%A0%87%E5%87%86/"/>
    
      <category term="WEB" scheme="https://double1000.github.io/blog/tags/WEB/"/>
    
      <category term="开发流程" scheme="https://double1000.github.io/blog/tags/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Notes | JSON</title>
    <link href="https://double1000.github.io/blog/2017/04/06/javascript-notes-json/"/>
    <id>https://double1000.github.io/blog/2017/04/06/javascript-notes-json/</id>
    <published>2017-04-06T06:23:54.000Z</published>
    <updated>2017-04-12T01:06:14.008Z</updated>
    
    <content type="html"><![CDATA[<p><img src="1.jpg"></p>
<ul>
<li>json(javascript object notaion)全称是javascript对象表示法,它是一种数据交换的文本格式,而不是一种数据交换的文本格式,而不是一种编程语言,用于读取结构化数据,JSON是设计成描述数据交换格式的，他也有自己的语法，这个语法是JavaScript的一个子集。</li>
</ul>
<h5 id="一-语法规则"><a href="#一-语法规则" class="headerlink" title="一. 语法规则"></a>一. 语法规则</h5><ol>
<li>JSON的语法可以表示以下三种类型的值。字符串,数值,布尔值,和null</li>
<li>字符串必须使用双引号表示,不能使用单引号,数值必须使用十进制,且不能使用NaN和Infinity</li>
<li>JSON不支持javascript中的特殊值undefined<h5 id="二-JSON与对象-数组的区别"><a href="#二-JSON与对象-数组的区别" class="headerlink" title="二. JSON与对象,数组的区别"></a>二. JSON与对象,数组的区别</h5></li>
<li>对象和数组都是作为一种复杂数据类型,表示的是一组有序的键值对儿</li>
<li>对象的每个键值对儿中的值可以是简单值,也可以是复杂数据类型的值</li>
<li>数组表示一组有序的值的列表可以通过数值索引来访问其中的值,数组的值可以是任意类型 – 简单值,对象,或数组</li>
<li>注意:数组或对象最后一个成员的后面,不能加逗号.</li>
<li>JSON不支持JavaScript中的特殊值undefined</li>
<li>JSON没有变量的概念</li>
<li>JSON中,对象的键名必须放在双引号里面</li>
<li>因为JSON不是JavaScript语句,所以没有末尾的分号<h5 id="三-JSON对象stringify-方法"><a href="#三-JSON对象stringify-方法" class="headerlink" title="三.JSON对象stringify()方法"></a>三.JSON对象stringify()方法</h5><h6 id="3-1-JSON-stringify-把javascript对象序列化"><a href="#3-1-JSON-stringify-把javascript对象序列化" class="headerlink" title="3-1. JSON.stringify();把javascript对象序列化"></a>3-1. JSON.stringify();<code>把javascript对象序列化</code></h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jsonobj = &#123;</div><div class="line">    <span class="string">"title"</span>:<span class="string">"javascript"</span>,</div><div class="line">    <span class="string">"group"</span>:&#123;</div><div class="line">        <span class="string">"name"</span>:<span class="string">"jia"</span>,</div><div class="line">        <span class="string">"tel"</span>:<span class="number">12345</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> jsonstringify = <span class="built_in">JSON</span>.stringify(jsonobj);</div><div class="line"><span class="comment">//&#123;"title":"javascript","group":&#123;"name":"jia","tel":12345&#125;&#125;</span></div><div class="line"></div><div class="line">如果对象的成员是<span class="literal">undefined</span>或函数，这个成员会被省略</div><div class="line">如果数组的成员是<span class="literal">undefined</span>或函数，则这些值被转成<span class="literal">null</span></div><div class="line"><span class="built_in">JSON</span>.stringify(&#123;</div><div class="line">  <span class="attr">a</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line">  <span class="attr">b</span>: <span class="literal">undefined</span>,</div><div class="line">  <span class="attr">c</span>: [ <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="literal">undefined</span> ]</div><div class="line">&#125;);</div><div class="line"><span class="comment">// "&#123;"c":[null,null]&#125;"</span></div><div class="line"></div><div class="line">stringify()方法把正则表达式和数学对象转换成空对象的字符串形式</div><div class="line"><span class="built_in">JSON</span>.stringify(<span class="regexp">/foo/</span>) <span class="comment">// "&#123;&#125;"</span></div><div class="line"><span class="built_in">JSON</span>.stringify(<span class="built_in">Math</span>) <span class="comment">// "&#123;&#125;"</span></div><div class="line"></div><div class="line">stringify()方法把日期对象和包装对象转换成字符串</div><div class="line"><span class="built_in">JSON</span>.stringify(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>)) <span class="comment">//"true"</span></div><div class="line"><span class="built_in">JSON</span>.stringify(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'123'</span>)) <span class="comment">//""123""</span></div><div class="line"><span class="built_in">JSON</span>.stringify(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>)) <span class="comment">//"1"</span></div><div class="line"><span class="built_in">JSON</span>.stringify(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">//""2016-09-20T02:26:38.294Z""</span></div><div class="line"></div><div class="line"><span class="built_in">JSON</span>.stringify()方法会忽略对象的不可遍历属性</div><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</div><div class="line">  <span class="string">'foo'</span>: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">'bar'</span>: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">JSON</span>.stringify(obj); <span class="comment">// &#123;"foo":1&#125;]</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="3-2-参数"><a href="#3-2-参数" class="headerlink" title="3-2. 参数"></a>3-2. 参数</h6><ul>
<li>JSON.stringify()除序列化的javascript对象外,还可以接受两个参数,这两个参数用于指定以不同的方式序列化JavaScript对象.</li>
<li>第一个参数是一个过滤器,可以是一个数组,也可以是一个函数</li>
<li>第二个参数是一个选项,在JSON字符串中保留缩进</li>
</ul>
<ol>
<li><p>当stringify()方法的第二个参数是一个数组时,这时相当于实现一个过滤器的功能<br>过滤器只对对象的第一层属性有效</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var jsonObj = &#123;</div><div class="line">    <span class="string">"title"</span>:<span class="string">"javascript"</span>,</div><div class="line">    <span class="string">"group"</span>:&#123;</div><div class="line">        <span class="string">"a"</span>:<span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">JSON.stringify(jsonObj,[<span class="string">"group"</span>,<span class="string">"a"</span>]) // &#123;<span class="string">"group"</span>:&#123;<span class="string">"a"</span>:<span class="number">1</span>&#125;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>过滤器对数组无效</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jsonObj =[<span class="number">1</span>,<span class="number">2</span>];</div><div class="line"><span class="built_in">JSON</span>.stringify(jsonObj,[<span class="string">"0"</span>])<span class="comment">//"[1,2]"</span></div></pre></td></tr></table></figure>
</li>
<li><p>stringify()方法的第二个参数也可以是一个函数。<br>传入的函数接收两个参数，属性(键)名和属性值</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">JSON.stringify(&#123;a:<span class="number">1</span>,b:<span class="number">2</span>&#125;,<span class="keyword">function</span>(key, <span class="keyword">value</span>)&#123;</div><div class="line">  <span class="keyword">if</span> (typeof <span class="keyword">value</span> === <span class="string">"number"</span>) &#123;</div><div class="line">    <span class="keyword">value</span> = <span class="number">2</span> * <span class="keyword">value</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">value</span>;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// "&#123;"a":2,"b":4&#125;"</span></div></pre></td></tr></table></figure>
</li>
<li><p>注意:属性名只能是字符串，而在值并非键值对儿结构的值时，键名可以是空字符串</p>
</li>
<li>stringify()方法还可以接受第三个参数，用于增加返回的JSON字符串的可读性</li>
<li>如果是数字，表示每个属性前面添加的空格(最多不超过10个)</li>
<li><p>如果是字符串(不超过10个字符)，则该字符串会添加在每行前面</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">JSON.stringify(&#123; p1:<span class="number">1</span>, p2:<span class="number">2</span> &#125;, null, '<span class="string">|-');</span></div><div class="line">返回:<span class="string">"&#123;</span></div><div class="line"><span class="string">|-"</span>p1<span class="string">": 1,</span></div><div class="line"><span class="string">|-"</span>p2<span class="string">": 2</span></div><div class="line">&#125;<span class="string">"</span></div></pre></td></tr></table></figure>
</li>
<li><p>toJSON();JSON.stringify()还是不能满足对某些对象进行自定义序列化的需求。在这些情况下,可以通过对象上调用toJSON()方法,返回其自身的JSON数据格式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="string">'foo'</span>,</div><div class="line">  <span class="attr">toJSON</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'bar'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">x</span>: o&#125;);<span class="comment">// '&#123;"x":"bar"&#125;'</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="四-JSON对象的parse-方法。"><a href="#四-JSON对象的parse-方法。" class="headerlink" title="四.JSON对象的parse()方法。"></a>四.JSON对象的parse()方法。</h5><ul>
<li>JSON.parse方法用于将JSON字符串转化成对象</li>
</ul>
<ol>
<li>如果传入的字符串不是有效的JSON格式，JSON.parse方法将报错</li>
<li>JSON.parse()方法也可以接收一个函数参数，在每个键值对儿上调用，这个函数被称为还原函数(reviver)。该函数接收两个参数，一个键和一个值，返回一个值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">如果还原函数返回<span class="literal">undefined</span>，则表示要从结果中删除相应的键；</div><div class="line">如果返回其他值，则将该值插入到结果中</div><div class="line"><span class="keyword">var</span> o = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a":1,"b":2&#125;'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (key === <span class="string">''</span>)&#123;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (key === <span class="string">'a'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> value + <span class="number">10</span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">o.a <span class="comment">// 11</span></div><div class="line">o.b <span class="comment">// undefined</span></div><div class="line"></div><div class="line">在将日期字符串转换为<span class="built_in">Date</span>对象时，经常要用到还原函数</div><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="string">"title"</span>: <span class="string">"javascript"</span>,</div><div class="line">    <span class="string">"date"</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2016</span>,<span class="number">9</span>,<span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> jsonStr = <span class="built_in">JSON</span>.stringify(book);</div><div class="line"><span class="comment">//'&#123;"title":"javascript","date":"2016-09-30T16:00:00.000Z"&#125;''</span></div><div class="line"><span class="built_in">console</span>.log(jsonStr)</div><div class="line"></div><div class="line"><span class="keyword">var</span> bookCopy = <span class="built_in">JSON</span>.parse(jsonStr,<span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(key == <span class="string">'date'</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(bookCopy.date.getFullYear());<span class="comment">//2016</span></div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>()类似于<span class="built_in">JSON</span>.parse()方法，可以将json字符串转换为json对象</div><div class="line"><span class="built_in">eval</span>(<span class="string">'('</span> + <span class="string">'&#123;"a":1&#125;'</span>+<span class="string">')'</span>).a;<span class="comment">//1</span></div><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a":1&#125;'</span>).a;<span class="comment">//1</span></div><div class="line"></div><div class="line"><span class="built_in">eval</span>(<span class="string">'('</span> + <span class="string">'&#123;"a":alert(1)&#125;'</span>+<span class="string">')'</span>).a;<span class="comment">//弹出1</span></div><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a":alert(1)&#125;'</span>).a;<span class="comment">//报错</span></div><div class="line">但是，<span class="built_in">eval</span>()可以执行不符合<span class="built_in">JSON</span>格式的代码，有可能会包含恶意代码</div><div class="line">所以，还是要尽量少使用<span class="built_in">eval</span>()</div></pre></td></tr></table></figure>
<h5 id="何时是JSON，何时不是JSON？"><a href="#何时是JSON，何时不是JSON？" class="headerlink" title="何时是JSON，何时不是JSON？"></a>何时是JSON，何时不是JSON？</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;json(javascript object notaion)全称是javascript对象表示法,它是一种数据交换的文本格式,而不是一种数据交换的文本格式,而不是一种编程语言,用于读取结构化数据,JSON是设计
    
    </summary>
    
      <category term="寄蜉蝣于天地,渺沧海之一粟" scheme="https://double1000.github.io/blog/categories/%E5%AF%84%E8%9C%89%E8%9D%A3%E4%BA%8E%E5%A4%A9%E5%9C%B0-%E6%B8%BA%E6%B2%A7%E6%B5%B7%E4%B9%8B%E4%B8%80%E7%B2%9F/"/>
    
    
      <category term="JavaScript" scheme="https://double1000.github.io/blog/tags/JavaScript/"/>
    
      <category term="Notes" scheme="https://double1000.github.io/blog/tags/Notes/"/>
    
      <category term="JSON" scheme="https://double1000.github.io/blog/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Notes | 面对对象</title>
    <link href="https://double1000.github.io/blog/2017/04/06/javascript-notes-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    <id>https://double1000.github.io/blog/2017/04/06/javascript-notes-面对对象/</id>
    <published>2017-04-06T06:12:35.000Z</published>
    <updated>2017-04-12T03:42:08.568Z</updated>
    
    <content type="html"><![CDATA[<p><img src="1.jpg"></p>
<h4 id="一-相关概念"><a href="#一-相关概念" class="headerlink" title="一.相关概念"></a>一.相关概念</h4><ul>
<li>面对对象是一种大家很熟悉的<code>程序设计思想</code>，是对真实世界的<code>抽象</code></li>
<li>面对对象的基础是<code>类</code>，通过类的封装继承来映射真实世界</li>
<li>JS也是面对对象编程语言，只不过它实现面对对象的思路是<code>基于原型（prototype),而不是类</code>，这种思路也叫<code>对象关联</code></li>
<li>每个对象都有一个<code>原型</code>（Object除外）这个原型，大概就像java中的父类</li>
<li>创建对象的方法，字面量，工厂模式，构造函数，原型，混合，<code>ES6提供的class类</code></li>
<li><strong>相关术语</strong>：<code>多态</code>/<code>动态绑定</code>/<code>继承</code>/<code>封装</code>/<code>属性</code>/<code>方法</code>/<code>消息</code>/<code>接口</code>/<code>对象持久性</code>/<code>原型链</code>/</li>
</ul>
<h4 id="二-术语解释"><a href="#二-术语解释" class="headerlink" title="二.术语解释"></a>二.术语解释</h4><ol>
<li><strong>多态</strong>：一个对象变量<code>可以引用多种实际类型</code>的现象叫做多态。在java和c++语言中指的是可以用子类对象赋给父类对象，说到多态，就要说说覆盖。<code>覆盖</code>实际上指在同一个函数原型的情况下，将父类的一个实现替换为子类的一个实现</li>
<li><strong>动态绑定</strong>：在运行时能够<code>自动选择</code>调用那个方法的现象叫做动态绑定</li>
<li><p><strong>继承</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">1. </span>公共操作和域放在超类</div><div class="line"><span class="bullet">2. </span>不要使用受保护的域 使用继承实现'is-a'关系</div><div class="line"><span class="bullet">3. </span>除非所有继承的方法都有意义，否则不要使用继承</div><div class="line"><span class="bullet">4. </span>在覆盖方法时，不要改变预期的行为</div><div class="line"><span class="bullet">5. </span>使用多态，而非类型信息</div><div class="line"><span class="bullet">6. </span>不要使用过多的反射</div></pre></td></tr></table></figure>
</li>
<li><p><strong>全局数据</strong>：如果设计合理，OO设计中根本不会出现<code>全局数据子类</code>的东西，这一点保证了OO系统中的<code>高度数据完整性</code>。</p>
</li>
<li><strong>数据隐藏</strong>：在OO术语中，数据表示为<code>属性</code>，行为表示为<code>方法</code>，限制对某些数据或方法的访问叫做<code>数据隐藏</code>，为了支持数据隐藏的概念，方法里提出了<code>访问方法</code>，和<code>设置方法</code>两种特殊方法</li>
<li><strong>封装</strong>：通过把<code>数据和方法合并到一个对象</code>里，以<code>控制对数据和方法的访问</code>，通常，一个对象不应该对另一个对象的内部数据进行操作，应该设计完成特定任务的小对象，而不是设计完成许多功能的大对象<ol>
<li><strong>对象数据方法表达方式</strong> ： <code>属性(attribute)</code>,特性(property)/<code>方法(method)</code>,行为(behavior)</li>
<li><strong>类和对象的关系</strong>：<code>类是创建对象的模板</code>，我们使用类来创建对象。当一个对象被创建时，我们说<code>对象被实例化</code>。<strong>对象被实例化后，才会在内存中存在</strong>。例子：在关系型数据库中，表的定义就是类，表中的行数据是对象</li>
<li><strong>消息</strong>：消息是<code>对象之间的通讯机制</code>。当对象A调用对象B的一个方法时，就是对象A在向对象B发送一个消息。</li>
<li><strong>接口</strong>： 最终<code>为用户提供服务的集合</code>。理想情况下，应该只为最终用户提供它们需要的服务。<code>接口要最小化</code>。</li>
<li><strong>对象持久性</strong>:指<code>保存对象的状态</code>。从而可以在以后恢复且使用。</li>
<li><strong>原型链</strong>:实例对象与原型之间的连接，叫做<code>原型链</code></li>
</ol>
</li>
</ol>
<h4 id="三-设计原则"><a href="#三-设计原则" class="headerlink" title="三.设计原则"></a>三.设计原则</h4><ul>
<li>找出变化之处，封装起来，不要把它们和不需要变化的代码混在一起<code>(策略模式)</code></li>
<li><code>针对接口编程</code>，而不是针对实现编程(策略模式)</li>
<li>多用<code>组合</code>，少用<code>继承</code>(策略模式)</li>
<li>设计具有<code>松耦合关系</code>的对象(观察者模式)</li>
<li>对<code>扩展开放</code>，对<code>修改封闭</code>(装饰者模式)</li>
<li>依赖倒置原则：要依赖抽象，不要依赖具体类(工厂模式)</li>
<li>最少知识原则：只和你的密友聊天(也叫黛尔特法则)</li>
<li>好莱坞原则：别调用我们，我们会调用你，即底层组件将自己挂钩到系统中，由高层组件决定合适和如果用底层组件(模板方法模式中由超类控制一切，当它们需要的时候，自然会去调用子类)</li>
<li><p>单一责任原则：<code>一个类应该只有一个引起变化的原因</code>。该原则体现了面对对象中的类聚概念。</p>
<h4 id="四-对象的创建"><a href="#四-对象的创建" class="headerlink" title="四.对象的创建"></a>四.对象的创建</h4><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>字面量</div><div class="line"><span class="built_in">var</span> Person = &#123;</div><div class="line"><span class="attribute">name</span> : <span class="string">"name"</span>,</div><div class="line"><span class="attribute">age</span> : <span class="string">"Age"</span>,</div><div class="line"><span class="attribute">method</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">注意:创建一个类似的对象，会产生大量的代码</div><div class="line"></div><div class="line"><span class="number">2.</span>工厂模式</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    <span class="built_in">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//1.原料</span></div><div class="line">    obj.name = name;<span class="comment">//2.加工</span></div><div class="line">    obj.age = age;</div><div class="line">    obj.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> obj;<span class="comment">//3.出场</span></div><div class="line">&#125;</div><div class="line"><span class="number">2</span><span class="number">-1.</span>解决多个类似对象声明问题。解决了实例化对象产生大量重复问题</div><div class="line"><span class="number">2</span><span class="number">-2.</span>识别问题，根本无法搞清楚它们到底是那个对象的实例</div><div class="line"></div><div class="line"><span class="number">3.</span>构造函数</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="number">3</span><span class="number">-1.</span>解决了重复实例化的问题,又解决了对象识别问题</div><div class="line"><span class="number">3</span><span class="number">-2.</span>有显示的创建对象,直接将属性和方法赋值给<span class="keyword">this</span>对象</div><div class="line"><span class="number">3</span><span class="number">-3.</span>没有<span class="keyword">return</span>语句,调用的时候前必须加<span class="keyword">new</span>调用,不然就是普通函数调用</div><div class="line"></div><div class="line"><span class="number">4.</span>原型方式</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">Person.prototype.name = <span class="string">"name"</span>; <span class="comment">//1.原型添加属性</span></div><div class="line">Person.prototype.age = <span class="string">"age"</span>;</div><div class="line">Person.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);    <span class="comment">//2.原型上添加方法</span></div><div class="line">&#125;</div><div class="line"><span class="number">4</span><span class="number">-1.</span>创建的每个函数都有一个prototype属性,这个属性是个对象</div><div class="line"><span class="number">4</span><span class="number">-2.</span>原型的好处可以让所有对象实例共享它所有包含的属性和方法</div><div class="line"><span class="number">4</span><span class="number">-3.</span>缺点是传参问题。</div><div class="line"></div><div class="line"><span class="number">5.</span>组合构造函数 + 原型模式</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name; <span class="comment">// 1.属性写在构造函数里面</span></div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;;</div><div class="line">Person.prototype = &#123;  <span class="comment">// 2.方法写在原型里面</span></div><div class="line">    <span class="attribute">constructor</span> : Person,</div><div class="line">    <span class="attribute">method</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="number">5</span><span class="number">-1.</span>这种混合模式很好解决了传参和引用共享的难题。</div><div class="line"><span class="number">5</span><span class="number">-2.</span>原型模式,不管是否调用了原型中的共享方法,都会初始化原型中的方法.</div><div class="line"><span class="number">5</span><span class="number">-3.</span>在声明一个对象时构造函数+原型部分让人感觉怪异,最好就是把构造函数和原型封装到一起</div><div class="line"></div><div class="line"><span class="number">6.</span>动态原型模式</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123; <span class="comment">//1.将所有信息封装到函数体内</span></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.method != <span class="string">'function'</span>)&#123; <span class="comment">// 2.仅在第一次调用时初始化</span></div><div class="line">        Person.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="number">6</span><span class="number">-1.</span>注意：不可以再使用字面量的方式重写原型，因为会切断实例和新原型之间的联系</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="五-继承"><a href="#五-继承" class="headerlink" title="五.继承"></a>五.继承</h4><blockquote>
<p>继承是面对对象中一个比较核心的概念，其它面对对象语言都会用两种方式实现继承，<em>一个是接口实现</em>/<em>一个是继承</em>/ ES只支持继承，不支持接口实现，而实现继承的方式是依靠原型链完成</p>
</blockquote>
<ol>
<li>JavaScript里,被继承的函数被称为超类（父类,基类也行）</li>
<li>继承的函数称为子类型（子类，派生类）</li>
<li><p>继承也有之前问题,字面量重写原型会中断关系,使用引用类型的原型,并且子类型还无法给超类型传递参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>对象冒充(伪造对象/经典继承)</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name,age</span>)</span>&#123; <span class="comment">// 父类</span></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">birth,name,age</span>)</span>&#123; <span class="comment">// 子类</span></div><div class="line">    Father.call(<span class="keyword">this</span>,name,age,birth); <span class="comment">//对象冒充，给超类传参</span></div><div class="line">&#125;</div><div class="line"><span class="number">1</span><span class="number">-1.</span>这种继承解决了引用共享和超类无法传参的问题。但没有原型,复用则无从谈起。</div><div class="line"></div><div class="line"><span class="number">2.</span>原型式继承</div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">     <span class="keyword">this</span>.name = name;</div><div class="line"> &#125;</div><div class="line"> Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">'parent name:'</span>, <span class="keyword">this</span>.name);</div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">     <span class="keyword">this</span>.name = name;</div><div class="line"> &#125;</div><div class="line"> Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'father'</span>);</div><div class="line"> Child.prototype.constructor = Child;</div><div class="line"> Child.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">'child name:'</span>, <span class="keyword">this</span>.name);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'son'</span>);</div><div class="line"> child.sayName();    <span class="comment">// child name: son</span></div><div class="line"></div><div class="line"><span class="number">2</span><span class="number">-1.</span>子类型无法给超类型传递参数,在面向对象的继承中,我们总希望通过 <span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'son'</span>, <span class="string">'father'</span>).让子类去调用父类的构造器来完成继承。而不是通过像这样 <span class="keyword">new</span> Parent(<span class="string">'father'</span>) 去调用父类。</div><div class="line"><span class="number">2</span><span class="number">-2.</span>Child.prototype.sayName 必须写在 Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'father'</span>); 之后，不然就会被覆盖掉。</div><div class="line"></div><div class="line"><span class="number">3.</span> 类式继承</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'parent name:'</span>, <span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line">Parent.prototype.doSomthing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'parent do something!'</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, parentName</span>) </span>&#123;</div><div class="line">    Parent.call(<span class="keyword">this</span>, parentName);</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Child.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'child name:'</span>, <span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'son'</span>);</div><div class="line">child.sayName();      <span class="comment">// child name: son</span></div><div class="line">child.doSomthing();   <span class="comment">// TypeError: child.doSomthing is not a function</span></div><div class="line"></div><div class="line"><span class="number">3</span><span class="number">-1.</span>相当于 Parent 这个函数在 Child 函数中执行了一遍，并且将所有与 <span class="keyword">this</span> 绑定的变量都切换到了 Child 上，这样就克服了第一种方式带来的问题。</div><div class="line"><span class="number">3</span><span class="number">-2.</span>缺点：没有原型,每次创建一个 Child 实例对象时候都需要执行一遍 Parent 函数,无法复用一些公用函数。</div><div class="line"></div><div class="line"><span class="number">4.</span> 组合式继承：前两种方式的结合</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'parent name:'</span>, <span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line">Parent.prototype.doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'parent do something!'</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, parentName</span>) </span>&#123;</div><div class="line">    Parent.call(<span class="keyword">this</span>, parentName); <span class="comment">//第二次调用</span></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Child.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'child name:'</span>, <span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();</div><div class="line">Child.prototype.construtor = Child;</div><div class="line"></div><div class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'son'</span>); <span class="comment">//第一次调用</span></div><div class="line">child.sayName();       <span class="comment">// child name: son</span></div><div class="line">child.doSomething();   <span class="comment">// parent do something!</span></div><div class="line"></div><div class="line"><span class="number">4</span><span class="number">-1.</span>组合式继承是比较常用的一种继承方法,其背后的思路是使用原型链实现对原型属性和方法的继承,而通过借用构造函数来实现对实例属性的继承。</div><div class="line"><span class="number">4</span><span class="number">-2.</span>通过在原型上定义方法实现了函数复用,又保证每个实例都有它自己的属性。</div><div class="line"><span class="number">4</span><span class="number">-3.</span>缺点:组合式继承是 JS 最常用的继承模式,但组合继承使用过程中会被调用两次：一次是创建子类型的时候，另一次是在子类型构造函数的内部。</div><div class="line"></div><div class="line"><span class="number">5.</span>  寄生组合式继承</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'parent name:'</span>, <span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, parentName</span>) </span>&#123;</div><div class="line">    Parent.call(<span class="keyword">this</span>, parentName);</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">proto</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">    F.prototype = proto;</div><div class="line">    F.prototype.construtor = F;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line">Child.prototype = create(Parent.prototype);</div><div class="line">Child.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'child name:'</span>, <span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line">Child.prototype.construtor = Child;</div><div class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent(<span class="string">'father'</span>);</div><div class="line">parent.sayName();    <span class="comment">// parent name: father</span></div><div class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">'son'</span>, <span class="string">'father'</span>);</div><div class="line">child.sayName();     <span class="comment">// child name: son</span></div><div class="line"></div><div class="line"><span class="number">5</span><span class="number">-1.</span>这就是所谓的寄生组合式继承方式,跟组合式继承的区别在于,他不需要在一次实例中调用两次父类的构造函数,假如说父类的构造器代码很多,还需要调用两次的话对系统肯定会有影响，</div><div class="line"><span class="number">5</span><span class="number">-2.</span>寄生组合式继承的思想在于,用一个 F 空的构造函数去取代执行了 Parent 这个构造函数。</div><div class="line"></div><div class="line">在上面的代码中,我们手动创建了一个 create 函数,但是其实是存在于 <span class="built_in">Object</span> 对象中,不需要我们手动去创建</div><div class="line"></div><div class="line"><span class="number">6.</span>  ES <span class="number">6</span> 继承</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    doSomething() &#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'parent do something!'</span>);</div><div class="line">    &#125;</div><div class="line">    sayName() &#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'parent name:'</span>, <span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name, parentName) &#123;</div><div class="line">	<span class="keyword">super</span>(parentName);</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    sayName() &#123;</div><div class="line"> 	<span class="built_in">console</span>.log(<span class="string">'child name:'</span>, <span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="string">'son'</span>, <span class="string">'father'</span>);</div><div class="line">child.sayName();            <span class="comment">// child name: son</span></div><div class="line">child.doSomething();        <span class="comment">// parent do something!</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Parent(<span class="string">'father'</span>);</div><div class="line">parent.sayName();           <span class="comment">// parent name: father</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="六-方法"><a href="#六-方法" class="headerlink" title="六.方法"></a>六.方法</h4><ul>
<li>Object.getPrototypeof(),查看一个对象的原型。跟<code>__proto__(隐式引用)</code>返回结果一样</li>
<li>Object.setPrototypeOf(obj,prototype),obj要设置其原型的对象,该对象的新原型</li>
<li>Obj.constructor 查看对象的构造函数</li>
<li>Obj.hasOwnProperty(),判断属性是在构造函数的实例里,还是在原型链</li>
</ul>
<h4 id="七-难点"><a href="#七-难点" class="headerlink" title="七.难点"></a>七.难点</h4><ol>
<li><strong>proto</strong>与prototype的区别？</li>
</ol>
<ul>
<li>无论对象是如何创建的,默认的原型都是Object,通过构造函数来创建对象,函数本身也是一个对象。函数的<code>prototype</code>属性只有在当作构造函数创建的时候，把自身的prototype属性值赋给对象的原型,而实际上,作为函数本身,它的原型应该是<code>function</code>，然后function对象的原型才是Object,建议使用ES6推荐的查看原型和设置原型的方法。<code>instance.constructor.prototype = instance.__proto__</code></li>
<li>只有<code>函数对象才有prototype</code>属性。</li>
</ul>
<ol>
<li>new 操作符具体干了什么呢？</li>
</ol>
<ul>
<li><code>创建</code>一个新对象</li>
<li>将构造函数的<code>作用域赋给新对象</code>(因此this就指向了这个新对象)</li>
<li><code>执行</code>构造函数中的代码(为这个新对象添加属性和方法)</li>
<li><code>返回</code>新对象</li>
</ul>
<ol>
<li>构造函数与普通函数的区别？</li>
</ol>
<ul>
<li>构造函数本身也是函数，只不过可以用来<code>构建对象</code>而已</li>
<li>调用方式不同,任何函数只要通过<code>new操作符</code>来调用,那它就可以作为构造函数,而任何函数如果不通过new操作符来调用,跟普通函数并无二致。如果不使用new操作符,属性和方法都被添加给window对象了。当在全局作用域调用一个函数时,this对象总是指向<code>Global对象</code>(在浏览器中就是window对象)</li>
</ul>
<ol>
<li>基于类的面对对象和基于原型的面对对象方式不同之处？</li>
</ol>
<ul>
<li>在基于类的面对对象方式中,对象(Object)依靠<code>类(class)</code>来产生。</li>
<li>在基于原型的面对对象方式中,对象则是依靠<code>构造器(constructor)</code>利用<code>原型(prototype)</code>构造出来的。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;一-相关概念&quot;&gt;&lt;a href=&quot;#一-相关概念&quot; class=&quot;headerlink&quot; title=&quot;一.相关概念&quot;&gt;&lt;/a&gt;一.相关概念&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;面对对象是一种大家很熟悉的&lt;code&gt;程序设计
    
    </summary>
    
      <category term="寄蜉蝣于天地,渺沧海之一粟" scheme="https://double1000.github.io/blog/categories/%E5%AF%84%E8%9C%89%E8%9D%A3%E4%BA%8E%E5%A4%A9%E5%9C%B0-%E6%B8%BA%E6%B2%A7%E6%B5%B7%E4%B9%8B%E4%B8%80%E7%B2%9F/"/>
    
    
      <category term="JavaScript" scheme="https://double1000.github.io/blog/tags/JavaScript/"/>
    
      <category term="Notes" scheme="https://double1000.github.io/blog/tags/Notes/"/>
    
      <category term="prototype" scheme="https://double1000.github.io/blog/tags/prototype/"/>
    
      <category term="继承" scheme="https://double1000.github.io/blog/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Notes | 字符串</title>
    <link href="https://double1000.github.io/blog/2017/04/06/javascript-notes-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://double1000.github.io/blog/2017/04/06/javascript-notes-字符串/</id>
    <published>2017-04-06T03:48:28.000Z</published>
    <updated>2017-04-12T01:06:58.922Z</updated>
    
    <content type="html"><![CDATA[<p><img src="1.jpg"></p>
<h4 id="一-字符串的属性"><a href="#一-字符串的属性" class="headerlink" title="一.字符串的属性"></a>一.字符串的属性</h4><ol>
<li>length:字符串的每个实例都有一个length属性,表示字符串中的字符个数,由于字符串是不变的，所以字符串的长度也不可变<blockquote>
<p>特性:字符串的length属性不会再<code>for/in</code>循环中枚举,也不能通过<code>delete</code>删除,索引从0开始</p>
<h4 id="二-字符串通用方法"><a href="#二-字符串通用方法" class="headerlink" title="二.字符串通用方法"></a>二.字符串通用方法</h4><p><code>String</code>类型是与字符串对象的包装类型,继承了Object的通用方法</p>
</blockquote>
</li>
<li>toString();该方法返回string的原始字符串值。</li>
<li>toLocaleString();该方法返回string的原始字符串值。</li>
<li>valueOf();该方法返回string的原始字符串值<h4 id="三-字符串实例方法"><a href="#三-字符串实例方法" class="headerlink" title="三.字符串实例方法"></a>三.字符串实例方法</h4><h5 id="1-访问字符方法"><a href="#1-访问字符方法" class="headerlink" title="1. 访问字符方法"></a>1. 访问字符方法</h5><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">1. String.prototype.charAt(number);</div><div class="line">1-1. charAt()方法接受一个基于0的字符串位置的参数,返回指定位置的字符。</div><div class="line">1-2. 当参数为空或者NaN时,默认参数为0</div><div class="line">1-3. 当参数超出范围时,则返回一个空字符串</div><div class="line"></div><div class="line">var str = &apos;hello&apos;;</div><div class="line">console.log(str.charAt(NaN)); // h</div><div class="line">注意：charAt()方法涉及到Number()函数的隐式类型转换,如果转换为数值,如果转换为NaN,则输出第0个字符</div><div class="line">注意: str.charAt(pos)与str.substring(pos, pos+1)、str.substr(pos,1)、str.slice(pos,pos+1)的结果相等</div><div class="line"></div><div class="line">2. [number]中括号</div><div class="line">2-1. ES5,使用方括号加数字索引来访问字符串中的特定字符。</div><div class="line">2-2. 如果参数超出范围或是NaN时,则输出undefined;没有参数,会报错</div><div class="line">2-3. 该方法没有Number()转型函数的隐式转换,但参数为单数值数组时可转换为数值</div><div class="line"></div><div class="line">3. String.prototype.charCodeAt(number);</div><div class="line">3-1. 类似charAt()方法,返回的是指定位置的字符16位Unicode编码</div><div class="line">3-2. 返回值是一个16位的整数,在0~65525之间,即0x0000 - 0xffff之间</div><div class="line">3-3. 参数为空或NaN时,默认参数为0,当参数超出范围时,则返回NaN</div><div class="line">3-4. 注意:charCodeAt()方法涉及到Number()函数的隐式类型转换,如果转换为数值,则按照上述规则输出相应值;如果转换为NaN,则输出第0个字符的字符编码</div><div class="line"></div><div class="line">4. String.fromCharCode();</div><div class="line">4-1. 这是一个属于String的静态方法</div><div class="line">4-2. 这个方法的任务是接受一个或多个字符编码,然后把它们转换成一个字符串。</div><div class="line">4-3. 从本质上看,这个方法与实例方法charCodeAt()执行的是相反的操作,若参数为空NaN时,则返回空字符串</div><div class="line">4-4. 若参数超出0~65535的范围,则输出字符不可控</div><div class="line">注意:如果一个字符占用四字节,则需要拆分两个字符表示</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="2-字符串拼接"><a href="#2-字符串拼接" class="headerlink" title="2.字符串拼接"></a>2.字符串拼接</h5><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1. String.prototype.concat();</div><div class="line">1-1. concat()方法用于将一个或多个字符串拼接起来,返回拼接得到的新字符串</div><div class="line">1-2. 返回拼接得到的新字符串,而源字符串不发生改变</div><div class="line">1-3. 若参数(第一个参数除外)不是字符串,则听过String()方法隐士转换为字符串,再进行字符串拼接</div><div class="line">注意:第一个参数只能是字符串,如果是其他类型(数组除外)则报错</div><div class="line">注意:由于数组也存在concat()方法,参数会按照首先出现的参数是数组还是字符串来决定如何转换</div><div class="line"></div><div class="line">2. +(加号运算符)</div><div class="line">2-1. 实践中使用更多的还是加号运算符。使用加号运算符再许多时候都比concat简单易行</div><div class="line">注意:当操作数其中一个是字符串,或者对象转换为字符串时,才进行字符串拼接</div></pre></td></tr></table></figure>
<h5 id="3-创建子字符串"><a href="#3-创建子字符串" class="headerlink" title="3.创建子字符串"></a>3.创建子字符串</h5><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">1. String.prototype.slice();</div><div class="line">1-1. slice(start,end),返回这个字符串中从start位置的字符到(但不包含)end位置的字符的一个子字符串.</div><div class="line">1-2. 如果end为end为undefined或不存在,则返回从start位置到字符串结尾的所有字符</div><div class="line">1-3. 如果start是负数,则start=max(length + start,0);</div><div class="line">1-4. 如果end是负数,则end=max(length + end,0);</div><div class="line">注意:slice()方法涉及到Number()转型函数的隐式类型转换，当start被转换为NaN时，相当于start = 0；当end被转换为NaN时(end为undefined除外)，则输出空字符串</div><div class="line"></div><div class="line">2. String.prototype.substring();</div><div class="line">2-1. substring(start,end)返回这个字符串中从start位置的字符到(但不包含)end位置的字符的一个子字符串；</div><div class="line">2-2. 如果end为undefined或不存在，则返回从start位置到字符串结尾的所有字符。</div><div class="line">2-3. 同样地，substring()方法也涉及到Number()转型函数的隐式类型转换</div><div class="line">注意:如果任一参数是NaN或负数，则被0取代</div><div class="line">注意:如果任一参数大于字符串长度，则被字符串长度取代</div><div class="line">注意:如果start 大于 end，则交换它们的值</div><div class="line"></div><div class="line">3.String.prototype.substr();</div><div class="line">3-1. substr(start,end)end代表返回的子字符串的字符个数,该方法返回这个字符串中从start位置的字符开始的end个字符的一个子字符串</div><div class="line">3-2. 如果end为undefined或不存在，则返回从start位置到字符串结尾的所有字符</div><div class="line">3-3. 如果start是负数，则start = max(length + start,0)</div><div class="line">3-4. 如果start是NaN，则相当于start = 0</div><div class="line">注意:如果end是负数或NaN，则end = 0，因此会返回空字符串</div><div class="line">注意:start和end无法交换位置</div><div class="line">注意:该方法不是ECMAScript标准，已经被弃用</div><div class="line">注意:substr()方法也涉及到Number()转型函数的隐式类型转换</div></pre></td></tr></table></figure>
<h5 id="3-大小写转换"><a href="#3-大小写转换" class="headerlink" title="3.大小写转换"></a>3.大小写转换</h5><ol>
<li>toUpperCase()方法将字符串转换成大写;</li>
<li>toLowerCase()方法将字符串转换成小写;</li>
<li>toLocaleUpperCase()方法将字符串转换成大写(针对地区);</li>
<li>toLocaleLowerCase()方法将字符串转换成小写(针对地区);<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意:在不知道自己的代码将在哪个语言环境中运行的情况下，使用针对地区的方法更稳妥</div><div class="line">注意:这<span class="number">4</span>种方法均不支持<span class="built_in">String</span>()隐式类型转换，只支持字符串类型</div><div class="line">注意:大小写转换方法可以连续使用</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="4-查找子串位置"><a href="#4-查找子串位置" class="headerlink" title="4.查找子串位置"></a>4.查找子串位置</h5><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">有两个从字符串中查找子字符串位置的方法:indexOf()和lastIndexOf()。</div><div class="line">查找子串位置的方法同访问字符方法charAt()和中括号[]方法有相反的地方，一个通过字符串查找位置，一个则是通过位置查找字符</div><div class="line"></div><div class="line">1. String.prototype.indexOf();</div><div class="line">1-1. indexOf(searchString,start)方法接收searchString和start两个参数，返回searchString首次出现的位置，如果没有找到则返回-1</div><div class="line">1-2. 该方法会隐式调用String()转型函数，将searchString非字符串值转换为字符串；隐式调用Number()转型函数，将start非数字值(undefined除外)转换为数值</div><div class="line">1-3. searchString表示要搜索的子字符串；start表示该搜索的开始位置，若忽略该参数或该参数为undefined、NaN或负数时，start = 0</div><div class="line"></div><div class="line">2.String.prototype.lastIndexOf();</div><div class="line">2-1. 与indexOf()不同，lastIndexOf()从右向左查找</div><div class="line">2-2. lastIndexOf(searchString,start)方法接收searchString和start两个参数，返回searchString第一次出现的位置，如果没有找到则返回-1</div><div class="line">2-3. 同样地，该方法会隐式调用String()转型函数，将searchString非字符串值转换为字符串；隐式调用Number()转型函数，将start非数字值(undefined除外)转换为数值</div><div class="line">2-4. searchString表示要搜索的子字符串；start表示该搜索的开始位置，若忽略该参数或该参数为undefined、NaN时，start = length - 1；若start为负数，start = 0</div><div class="line"></div><div class="line">**例子:查找出字符串所有符合条件的子字符串**</div><div class="line">function allIndexOf(str,value)&#123;</div><div class="line">    var result = [];</div><div class="line">    var pos = str.indexOf(value);</div><div class="line">    while(pos &gt; -1)&#123;</div><div class="line">        result.push(pos);</div><div class="line">        pos = str.indexOf(value,pos+value.length);</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">console.log(allIndexOf(&apos;helllhelllhelll&apos;,&apos;ll&apos;));//[2,7,12]</div></pre></td></tr></table></figure>
<h5 id="5-正则匹配方法"><a href="#5-正则匹配方法" class="headerlink" title="5.正则匹配方法"></a>5.正则匹配方法</h5><p>javascript中的一些正则操作如查找和测试等可以通过RegExp的方法实现，而切分和替换等另一些操作可以通过String类的方法实现String类共有match()、search()、replace()、split()这4种正则匹配方法<br><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">1. String.prototype.match();</div><div class="line">1-2. match()方法只接受一个为正则或字符串的参数，并以数组的形式返回匹配的内容。</div><div class="line">1-3. 这个方法类似于正则表达式RegExp的exec()方法，只是调换了RegExp和String对象的位置</div><div class="line">1-4. 若匹配失败,则match()方法返回null</div><div class="line"></div><div class="line">&apos;x&apos;.match(/y/);//null</div><div class="line">var string = &apos;cat,bat,sat,fat&apos;;</div><div class="line">var pattern = /.at/g;</div><div class="line">var matches = string.match(pattern);</div><div class="line">console.log(matches,matches.index,matches.input);//[&quot;cat&quot;, &quot;bat&quot;, &quot;sat&quot;, &quot;fat&quot;] undefined undefined</div><div class="line">var matches = string.match(pattern);</div><div class="line">console.log(matches,matches.index,matches.input);//[&quot;cat&quot;, &quot;bat&quot;, &quot;sat&quot;, &quot;fat&quot;] undefined undefined</div><div class="line"></div><div class="line">var string = &apos;cat,bat,sat,fat&apos;;</div><div class="line">var pattern = /.at/;</div><div class="line">var exec = pattern.exec(string);</div><div class="line">console.log(exec,exec.index,exec.input);//[&apos;cat&apos;] 0 &apos;cat,bat,sat,fat&apos;</div><div class="line">var exec = pattern.exec(string);</div><div class="line">console.log(exec,exec.index,exec.input);//[&apos;cat&apos;] 0 &apos;cat,bat,sat,fat&apos;</div><div class="line"></div><div class="line">例子：找出字符串中所有的数字</div><div class="line">var str1 = &apos;j1h342jg24g234j 3g24j1&apos;;</div><div class="line">array = str1.match(/\d+/g);</div><div class="line">console.log(array);//[&quot;1&quot;, &quot;342&quot;, &quot;24&quot;, &quot;234&quot;, &quot;3&quot;, &quot;24&quot;, &quot;1&quot;]</div><div class="line"></div><div class="line">注意:若不设置全局标志，match()方法和exec()方法结果相同</div><div class="line">注意:设置全局标志后,exec()方法依然返回单次的匹配结果，而match()方法会返回一个字符串数组,其中包括各次成功匹配的文本，但没有index和input属性</div><div class="line">注意:match()方法作为字符串String的方法，接受参数为字符串，结果与不设置全局标志的正则表达式为参数相同，只返回第一个匹配项，且具有index和input属性</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">2. String.prototype.search();</div><div class="line">2-1. search()方法接受一个正则或字符串的参数,返回匹配的内容在字符串中首次出现的位置,</div><div class="line">2-2.类似于不能设置起始位置的indexOf,找不到返回-1</div><div class="line">注意:search()方法不执行全局匹配，忽略全局标志g，也会忽略RegExp对象的lastIndex属性，总是从字符串的开始位置开始搜索</div><div class="line"></div><div class="line">例子：找出匹配的所有位置</div><div class="line">function fnAllSearch(str,pattern)&#123;</div><div class="line">    var pos = str.search(pattern);</div><div class="line">    var length = str.match(pattern)[0].length;</div><div class="line">    var index = pos+length;</div><div class="line">    var result = [];</div><div class="line">    var last = index;</div><div class="line">    result.push(pos);</div><div class="line">    while(true)&#123;</div><div class="line">        str = str.substr(index);</div><div class="line">        pos = str.search(pattern);</div><div class="line">        if(pos === -1)&#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        length = str.match(pattern)[0].length;</div><div class="line">        index = pos+length;</div><div class="line">        result.push(last+pos);</div><div class="line">        last += index;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">console.log(fnAllSearch(&apos;cat23fbat246565sa3dftf44at&apos;,/\d+/));//[3,9,17,22]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">3. String.prototype.replace();</div><div class="line">3-1. replace()方法用于替换一个或多个子字符串。它接收两个参数：第一个是正则表达式或字符串，表示待查找的内容；第二个是字符串或函数，表示替换内容。</div><div class="line">3-2. 返回替换后的字符串</div><div class="line"></div><div class="line">注意:字符串替换，只能替换第一个子字符串</div><div class="line">var string = &apos;cat,bat,sat,fat&apos;;</div><div class="line">var result = string.replace(&apos;at&apos;,&apos;ond&apos;);</div><div class="line">console.log(result);//&apos;cond,bat,sat,fat&apos;</div><div class="line">注意:不设置全局标志g，也只能替换第一个子字符串</div><div class="line">var string = &apos;cat,bat,sat,fat&apos;;</div><div class="line">var result = string.replace(/at/,&apos;ond&apos;);</div><div class="line">console.log(result);//&apos;cond,bat,sat,fat&apos;</div><div class="line">注意:设置全局标志g，替换所有匹配的子字符串</div><div class="line">var string = &apos;cat,bat,sat,fat&apos;;</div><div class="line">var result = string.replace(/at/g,&apos;ond&apos;);</div><div class="line">console.log(result);//&apos;cond,bond,sond,fond&apos;</div><div class="line"></div><div class="line">replace()方法的第二个参数可以是函数，这样文本的处理更加灵活</div><div class="line">如果在只有一个匹配项的情况下，该方法会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置、原始字符串</div><div class="line">var string = &apos;cat,bat,sat,fat&apos;;</div><div class="line">var index = 0;</div><div class="line">var matchArray = [];</div><div class="line">var posArray = [];</div><div class="line">var text = &apos;&apos;;</div><div class="line">var result = string.replace(/at/g,function(match,pos,originalText)&#123;</div><div class="line">    matchArray.push(match);</div><div class="line">    posArray.push(pos);</div><div class="line">    text = originalText;</div><div class="line">    index++;</div><div class="line">    if(index % 2)&#123;</div><div class="line">        return &apos;wow&apos;;</div><div class="line">    &#125;else&#123;</div><div class="line">        return &apos;0&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">console.log(matchArray);//[&quot;at&quot;, &quot;at&quot;, &quot;at&quot;, &quot;at&quot;]</div><div class="line">console.log(posArray);//[1, 5, 9, 13]</div><div class="line">console.log(text);//&apos;cat,bat,sat,fat&apos;</div><div class="line">console.log(result);//&apos;cwow,b0,swow,f0&apos;</div><div class="line"></div><div class="line">例子:日期格式化</div><div class="line">var array = [&apos;2015.7.28&apos;,&apos;2015-7-28&apos;,&apos;2015/7/28&apos;,&apos;2015.7-28&apos;,&apos;2015-7.28&apos;,&apos;2015/7---28&apos;];</div><div class="line">function formatDate(date)&#123;</div><div class="line">    return date.replace(/(\d+)\D+(\d+)\D+(\d+)/,&apos;$1年$2月$3日&apos;)</div><div class="line">&#125;</div><div class="line">var result = [];</div><div class="line">for(var i = 0 ; i &lt; array.length; i++)&#123;</div><div class="line">    result.push(formatDate(array[i]));</div><div class="line">&#125;</div><div class="line">console.log(result);//[&quot;2015年7月28日&quot;, &quot;2015年7月28日&quot;, &quot;2015年7月28日&quot;, &quot;2015年7月28日&quot;, &quot;2015年7月28日&quot;, &quot;2015年7月28日&quot;]</div><div class="line">例子:找出重复项最多的字符和个数</div><div class="line">var str = &apos;aaaaabbbbbdddddaaaaaaaffffffffffffffffffgggggcccccce&apos;;</div><div class="line">var pattern = /(\w)\1+/g;</div><div class="line">var maxLength = 0;</div><div class="line">var maxValue = &apos;&apos;;</div><div class="line">var result = str.replace(pattern,function(match,match1,pos,originalText)&#123;</div><div class="line">    if(match.length &gt; maxLength)&#123;</div><div class="line">        maxLength = match.length;</div><div class="line">        maxValue = match1;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">console.log(maxLength,maxValue);//18 &quot;f&quot;</div></pre></td></tr></table></figure>
<h5 id="六-split-方法"><a href="#六-split-方法" class="headerlink" title="六.split()方法"></a>六.split()方法</h5><ol>
<li>split()方法基于指定的分隔符将一个字符串分割成多个字符串，并将结果放在一个数组中，分隔符可以是字符串，也可以是一个RegExp</li>
<li>该方法可以接受第二个参数(可选)用于指定数组的大小，如果第二个参数为0-array.length范围内的值时按照指定参数输出，其他情况将所有结果都输出</li>
<li>若指定分隔符没有出现在字符串中，则以数组的形式返回原字符串的值</li>
<li>参数中的正则表达式是否使用全局标志g对结果没有影响<figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var colorText = &apos;red,blue,green,yellow&apos;;</div><div class="line">console.log(colorText.split(&apos;&apos;));//[&quot;r&quot;, &quot;e&quot;, &quot;d&quot;, &quot;,&quot;, &quot;b&quot;, &quot;l&quot;, &quot;u&quot;, &quot;e&quot;, &quot;,&quot;, &quot;g&quot;, &quot;r&quot;, &quot;e&quot;, &quot;e&quot;, &quot;n&quot;, &quot;,&quot;, &quot;y&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;w&quot;]</div><div class="line">console.log(colorText.split(&apos;,&apos;));//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]</div><div class="line">console.log(colorText.split(&apos;,&apos;,2));//[&quot;red&quot;, &quot;blue&quot;]</div><div class="line">console.log(colorText.split(&apos;,&apos;,6));//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]</div><div class="line">console.log(colorText.split(&apos;-&apos;));//[&quot;red,blue,green,yellow&quot;]</div><div class="line">console.log(colorText.split(/\,/));//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]</div><div class="line">console.log(colorText.split(/e/));//[&quot;r&quot;, &quot;d,blu&quot;, &quot;,gr&quot;, &quot;&quot;, &quot;n,y&quot;, &quot;llow&quot;]</div><div class="line">console.log(colorText.split(/[^\,]+/));//将除去逗号以外的字符串变为分隔符[&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;],IE8-会识别为[&quot;,&quot;,&quot;,&quot;,&quot;,&quot;]</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="七-去除首尾空格trim"><a href="#七-去除首尾空格trim" class="headerlink" title="七.去除首尾空格trim()"></a>七.去除首尾空格trim()</h5><ol>
<li>ECMAScript5为所有字符串定义了trim()方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空白字符，然后返回结果</li>
<li>由于trim()方法返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变,意思就是不改变原字符串<figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">正则模拟去除字符串首尾空格</div><div class="line">function fnTrim(str)&#123;</div><div class="line">    return str.replace(/^\s+|\s+$/,&apos;&apos;)</div><div class="line">&#125;</div><div class="line">console.log(fnTrim(&apos;hello world&apos;));//&apos;hello world&apos;</div></pre></td></tr></table></figure></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;一-字符串的属性&quot;&gt;&lt;a href=&quot;#一-字符串的属性&quot; class=&quot;headerlink&quot; title=&quot;一.字符串的属性&quot;&gt;&lt;/a&gt;一.字符串的属性&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;length:字符串的每个实例
    
    </summary>
    
      <category term="寄蜉蝣于天地,渺沧海之一粟" scheme="https://double1000.github.io/blog/categories/%E5%AF%84%E8%9C%89%E8%9D%A3%E4%BA%8E%E5%A4%A9%E5%9C%B0-%E6%B8%BA%E6%B2%A7%E6%B5%B7%E4%B9%8B%E4%B8%80%E7%B2%9F/"/>
    
    
      <category term="JavaScript" scheme="https://double1000.github.io/blog/tags/JavaScript/"/>
    
      <category term="Notes" scheme="https://double1000.github.io/blog/tags/Notes/"/>
    
      <category term="字符串" scheme="https://double1000.github.io/blog/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Notes | 函数</title>
    <link href="https://double1000.github.io/blog/2017/04/06/javascript-notes-%E5%87%BD%E6%95%B0/"/>
    <id>https://double1000.github.io/blog/2017/04/06/javascript-notes-函数/</id>
    <published>2017-04-06T03:23:02.000Z</published>
    <updated>2017-04-12T10:15:09.102Z</updated>
    
    <content type="html"><![CDATA[<p><img src="1.jpg"></p>
<h4 id="一-函数定义"><a href="#一-函数定义" class="headerlink" title="一.函数定义"></a>一.函数定义</h4><ul>
<li>函数是一段代码,它只定义一次，但可以被执行或调用多次</li>
<li>函数即对象,每个函数都是Function构造函数的实例,因此函数名实际上也是一个指向函数对象的指针,不会与某个函数绑定</li>
<li>函数是搭建JavaScript的基本构件之一。一个函数就是一段JavaScript程序——包含用于执行某一任务或计算的一系列语句。</li>
<li>要使用某一个函数，你必需在想要调用这个函数的执行域的某处定义它。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">写法一:函数声明(推荐)</div><div class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参</span>)</span>&#123;</div><div class="line">    函数体;</div><div class="line">    返回值;</div><div class="line">&#125;</div><div class="line">写法二:函数表达式(推荐)</div><div class="line"><span class="keyword">var</span> 函数名 = <span class="function"><span class="keyword">function</span>(<span class="params">形参</span>)</span>&#123;</div><div class="line">    函数体;</div><div class="line">    返回值;</div><div class="line">&#125;</div><div class="line">写法三:<span class="built_in">Function</span>构造函数(不推荐)</div><div class="line"><span class="keyword">var</span> 函数名 = <span class="keyword">new</span> <span class="built_in">Function</span>(形参,返回值);</div></pre></td></tr></table></figure>
<h4 id="二-函数特性"><a href="#二-函数特性" class="headerlink" title="二.函数特性"></a>二.函数特性</h4><ol>
<li>由于函数名仅仅是指向函数的指针,因此函数名与包含对象指针的其他变量没有声什么不同,换句话说。一个函数可能会有多个名字</li>
<li>函数没有重载,后声明的函数会覆盖前面的函数</li>
<li>作为值的函数</li>
</ol>
<h4 id="三-函数声明与函数表达式"><a href="#三-函数声明与函数表达式" class="headerlink" title="三.函数声明与函数表达式"></a>三.函数声明与函数表达式</h4><ol>
<li>对于函数，只有函数声明会被提升到顶部，而不包括函数表达式</li>
<li>解析器会率先读取<strong>函数声明</strong>,并让其在执行代码之前可用</li>
<li>解析器对于<strong>函数表达式</strong>则必须等到执行到它所在的代码行,才会真正被解释执行</li>
<li>函数表达式   表达式定义的函数，称为匿名函数。匿名函数没有函数提升</li>
</ol>
<h4 id="四-arguments和this"><a href="#四-arguments和this" class="headerlink" title="四.arguments和this"></a>四.arguments和this</h4><ul>
<li>函数的内部有两个特殊对象<code>arguments</code>和<code>this</code></li>
<li>其中<code>arguments</code>是一个类数组对象,包含传入函数中的所有参数(形参)<blockquote>
<p>Array.prototype.slice.call(argumets) / [].slice.call(arguments);</p>
</blockquote>
</li>
<li><p><code>arguments</code>对象下面有一个<code>callee</code>的属性,该属性是一个指针,指向拥有这个<code>arguments</code>对象的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">经典的阶乘函数</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> num*<span class="built_in">arguments</span>.callee(num<span class="number">-1</span>); <span class="comment">//消除耦合</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>this</code>引用的是函数据以执行的环境对象</p>
</li>
</ul>
<h4 id="五-函数的属性"><a href="#五-函数的属性" class="headerlink" title="五.函数的属性"></a>五.函数的属性</h4><ol>
<li>每个函数都包含两个属性<code>length</code>和<code>prototype</code></li>
<li><p><code>length</code>属性表示函数希望接受的<strong>命名参数的个数</strong></p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(num1,num2)</span>&#123;</span></div><div class="line">    <span class="keyword">return</span> num1+num2;</div><div class="line">&#125;;</div><div class="line">console.<span class="built_in">log</span>(sum.<span class="built_in">length</span>) <span class="comment">// 2</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>prototype</code>对于js的引用类型,<code>prototype</code>是它们所有实例方法的真正所在,诸如<code>toString()</code>,<code>valueOf()</code>都保存在prototype名下,只不过是通过各自对象的实例访问罢了,在创建<code>自定义引用类型</code>以及实现<code>继承</code>是很重要的。<code>prototype</code>属性是不可枚举的,因此使用<code>for-in</code>无法发现</p>
</li>
</ol>
<h4 id="六-函数的方法"><a href="#六-函数的方法" class="headerlink" title="六.函数的方法"></a>六.函数的方法</h4><ol>
<li>每个函数都包含<strong>非继承</strong>而来的方法:<code>apply()</code>,<code>call()</code>这两个方法的用途都是在特定的作用域中调用函数,实际上等于设置函数体内<code>this</code>对象的值.</li>
<li><p><code>apply()</code>方法接受两个参数,一个是<code>在其运行函数中的作用域</code>,另一个是<code>参数数组||Array实例||arguments对象</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">   <span class="keyword">return</span> num1+num2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">   <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>.arguments);<span class="comment">//传入arguments对象</span></div><div class="line">&#125;</div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>.[num1,num2]);<span class="comment">//传入数组</span></div><div class="line"> &#125;</div><div class="line"> <span class="built_in">console</span>.log(callSum(<span class="number">10</span>,<span class="number">10</span>));<span class="comment">//  20</span></div><div class="line"> <span class="built_in">console</span>.log(callSum2(<span class="number">10</span>,<span class="number">10</span>));<span class="comment">// 20</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>call()</code>方法跟<code>apply()</code>作用相同,第一个<code>this</code>值没变化,其余的参数都必须<code>直接传递给函数</code>传递给函数的参数必须逐个列举出来</p>
</li>
<li>事实上,传递参数并非<code>call()</code>方法跟<code>apply()</code>真正的用武之地;它们真正强大的地方是<code>能够扩充函数赖以运行的作用域</code></li>
</ol>
<h4 id="七-函数返回值-return"><a href="#七-函数返回值-return" class="headerlink" title="七.函数返回值 return"></a>七.函数返回值 return</h4><ol>
<li><code>return</code>就是<code>函数返回值</code>,作用把东西返回到函数外面来,在哪儿调用就返回到哪</li>
<li>函数<code>不仅可以返回数字,返回字符串,返回算式</code></li>
<li>函数参数,一次可以写多个进去,但是return返回值只能返回一个出去</li>
<li>函数可以没有return,结果:<code>undefined</code></li>
<li>函数返回值(函数可以把一些东西传到外面来)和函数传参(把一些东西传到函数里边去)</li>
</ol>
<h4 id="八-递归。"><a href="#八-递归。" class="headerlink" title="八.递归。"></a>八.递归。</h4><ul>
<li>一个函数可以指向并调用自身(call itself)。有三种方法可以达到这个目的：</li>
</ul>
<h4 id="八-参考来源"><a href="#八-参考来源" class="headerlink" title="八.参考来源"></a>八.参考来源</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions" target="_blank" rel="external">MDN-Function</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;一-函数定义&quot;&gt;&lt;a href=&quot;#一-函数定义&quot; class=&quot;headerlink&quot; title=&quot;一.函数定义&quot;&gt;&lt;/a&gt;一.函数定义&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;函数是一段代码,它只定义一次，但可以被执行或调
    
    </summary>
    
      <category term="寄蜉蝣于天地,渺沧海之一粟" scheme="https://double1000.github.io/blog/categories/%E5%AF%84%E8%9C%89%E8%9D%A3%E4%BA%8E%E5%A4%A9%E5%9C%B0-%E6%B8%BA%E6%B2%A7%E6%B5%B7%E4%B9%8B%E4%B8%80%E7%B2%9F/"/>
    
    
      <category term="JavaScript" scheme="https://double1000.github.io/blog/tags/JavaScript/"/>
    
      <category term="Notes" scheme="https://double1000.github.io/blog/tags/Notes/"/>
    
      <category term="函数" scheme="https://double1000.github.io/blog/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Notes | 数组</title>
    <link href="https://double1000.github.io/blog/2017/04/06/javascript-notes-%E6%95%B0%E7%BB%84/"/>
    <id>https://double1000.github.io/blog/2017/04/06/javascript-notes-数组/</id>
    <published>2017-04-05T16:00:34.000Z</published>
    <updated>2017-04-12T01:07:08.614Z</updated>
    
    <content type="html"><![CDATA[<p><img src="1.png"></p>
<ul>
<li>数组：相同数据类型按照一定顺序排列的集合</li>
<li>稀疏数组：所谓稀疏数组就是数组中大部分的内容值都未被使用(或为零),在数组中仅有少部分的空间使用</li>
<li>二维数组：二维数组本质上是以数组作为数组元素的数组，即“数组的数组”。</li>
<li>多维数组：二维数组以上的数组。既非线性也非平面的数组。</li>
<li>栈：栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照<code>先进后出</code>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。插入一般称为进栈（PUSH），删除则称为退栈（POP）。栈也称为后进先出表。</li>
<li>堆：一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</li>
<li>队列：是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</li>
<li>类数组：<code>拥有length属性</code>和<code>对应非负整数属性</code>的对象叫做<code>类数组</code></li>
</ul>
<h4 id="一-声明数组的方式"><a href="#一-声明数组的方式" class="headerlink" title="一.声明数组的方式"></a>一.声明数组的方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!--空的数组--&gt;</div><div class="line">var colors = new Array()</div><div class="line">&lt;!--数组长度为3--&gt;</div><div class="line">var colors = new Array(3)</div><div class="line">&lt;!--长度为2,两个项--&gt;</div><div class="line">var colors = new Array(&apos;red&apos;,&apos;blue&apos;)</div><div class="line">&lt;!--字面量方式--&gt;</div><div class="line">var colors = [&apos;red&apos;,&apos;blue&apos;,&apos;yellow&apos;];</div></pre></td></tr></table></figure>
<h4 id="二-数组的属性-基本方法"><a href="#二-数组的属性-基本方法" class="headerlink" title="二.数组的属性/基本方法"></a>二.数组的属性/基本方法</h4><ul>
<li>Array.length 数组的length,不是只读的,可以用来增删数组</li>
<li>Array.toString(),Array.toLocaleString(),Array.toValueOf();将数组转换成一个字符串</li>
<li>Array.concat(),连接数组。</li>
<li>Array.reverse(),数组反序。</li>
<li>Array.sort(),数组排序。</li>
<li>Array.join(),将数组元素连接起来以构建一个<code>字符串</code>跟<code>split</code>相反,不会更改原数组</li>
</ul>
<h4 id="三-数组相关操作"><a href="#三-数组相关操作" class="headerlink" title="三.数组相关操作"></a>三.数组相关操作</h4><ol>
<li><p>数组位置操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Array.indexof(search,<span class="keyword">start</span>);search参数表示搜索的项，<span class="keyword">start</span>表示搜索的位置。从左至右</div><div class="line">Array.lastIndexOf(<span class="keyword">search</span>,<span class="keyword">start</span>)从右到左</div></pre></td></tr></table></figure>
</li>
<li><p>数组slice()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var colors = [&apos;red&apos;,&apos;blue&apos;,&apos;yellow&apos;,&apos;white&apos;,&apos;black&apos;];</div><div class="line">1.Array.slice(start,end) 返回一个新数组，不会改变原来的的数组</div><div class="line">2.从start处截取end个字符长度(包含start不包含end)</div><div class="line">3.如果是负数,它声明从数组尾部开始算起的位置。也就是说,-1指最后一个元素,-2指倒数第二个元素</div><div class="line">例子：var color2 = colors.slice(1,3);//[&apos;blue&apos;,&apos;yellow&apos;];</div></pre></td></tr></table></figure>
</li>
<li><p>数组的splice()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Array.splice(start, deleteCount, value, ...)</div><div class="line">原数组var arr = [1,2,3,4,5,6,7,8]</div><div class="line">注意:这个方法会修改原数组</div><div class="line">1.start 开始插入和(或)删除的数组元素的下标。</div><div class="line">2.deleteCount 从start开始，包括start所指的元素在内要删除的元素个数，</div><div class="line">3.如果没有指定它，如果没有指定它。splice()将删除从start开始到原数组结尾的所有元素</div><div class="line">4.value  要插入数组的零个或多个值，从start所指的小标处开始插入</div><div class="line">一个删除表示删除 var arrb = arr.splice(4) 返回b[5,6,7,8] a变成[1,2,3,4]</div><div class="line">两个值表示从start开始删除end个, var arrc = arr.splice(1,2) arrc返回[2,3] arr 返回 [1,4,6,7,8]</div><div class="line">两个值以上指定位置插入，var arrd = arr.splice(1,0,2,3)    arrb返回[] arr返回[1,2,3,2,3,4,5,6,7,8]</div></pre></td></tr></table></figure>
</li>
<li><p>栈和队列方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">栈方法:操作数组最后的元素</div><div class="line">Array.push(),方法从数组尾部添加（都会改变原数组,都返回数组的新length长度值)</div><div class="line">Array.pop(),方法从数组尾部删除</div><div class="line">队列方法:操作数组头部首元素</div><div class="line">Array.unshift(),方法是从数组的头部添加</div><div class="line">Array.shift(),方法shift()将把array的第—个元素移出数组，返回那个元素的值</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="四-数组函数"><a href="#四-数组函数" class="headerlink" title="四.数组函数"></a>四.数组函数</h4><ol>
<li><p>数组归并方法：reduce(化简函数,初值),reduceRight(化简函数,初值);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">返回值:是一个单数组，与传入初值的类型相同</div><div class="line">化简函数(initValue,nextValue[,index][,array]);</div><div class="line">1. initValue 初始变量,默认为数组的第一个元素，函数第一次执行后的返回值作为函数第二次执行的初始变量</div><div class="line">2. nextValue 当前变量，如果指定了第二个参数，则该变量为数组的第一个元素的值</div><div class="line">3. index 当前变量对应元素在数组中的索引(从0开始);</div><div class="line">4. array 原数组对象</div><div class="line">-  reduce()从左到右,reduceRight()从右到左</div></pre></td></tr></table></figure>
</li>
<li><p>数组迭代方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 数组定义了5个迭代方法,map,forEach,filter,some,every</div><div class="line">2. 每个方法接受两个参数,要在每一项上运行的函数和运行该函数的作用域对象(可选的) -- 影响this的值</div><div class="line">3. 运行的函数项会接受三个参数(数组项中的值,该项在数组中的位置,数组对象);</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Array.prototype.map();</div><div class="line">var users = [</div><div class="line">    &#123;name:&apos;t1&apos;,email:&apos;t1@qq.com&apos;&#125;,</div><div class="line">    &#123;name:&apos;t2&apos;,email:&apos;t2@qq.com&apos;&#125;,</div><div class="line">    &#123;name:&apos;t3&apos;,email:&apos;t3@qq.com&apos;&#125;</div><div class="line">];</div><div class="line">1. 返回值:数组,方法对数组的每一项给定函数,返回每次函数调用结果组成的数组</div><div class="line">2. 语法糖:map()方法还可以用于类数组对象</div><div class="line">3. 注意:对于稀疏数组,map()方法不会实际上不存在的元素序号上调用函数</div><div class="line"></div><div class="line">例子：语法糖类数组</div><div class="line">Array.prototype.map.call(&apos;abc&apos;,function(item,index,arr)&#123;</div><div class="line">    return item.toUpperCase(); // [A,B,C]</div><div class="line">&#125;);</div><div class="line"></div><div class="line">例子:获取方法对象数组中的特定属性值</div><div class="line">var arr2 = user.map(function(item,index,arr)&#123;</div><div class="line">    return item.email;</div><div class="line">&#125;);</div><div class="line">// 返回 [&quot;t1@qq.com&quot;,&quot;t2@qq.com&quot;,&quot;t3@qq.com&quot;];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Array.prototype.forEach();</div><div class="line">1. 没有返回值,本质上跟for循环没有什么不同,如果需要返回值,一般使用map方法</div><div class="line">2. forEach()方法除了接受一个必须回掉函数参数,第二个参数还可以接受一个可选的上下文参数(改变回调函数this指向);</div><div class="line">3. [注意:] 对于稀疏数组,forEach()方法不会再实际上不存在元素序号上调用函数</div><div class="line">4. [注意:] forEach()方法无法在所有元素都传递给调用的函数之前终止遍历,也就是说,没有像for循环中使用相应的break语句,如果提前终止,必须把forEach()方法放在一个try块中,并能抛出异常</div><div class="line"></div><div class="line">例子:改变函数的上下文</div><div class="line">var out = [];</div><div class="line">[1,2,3].forEach(function(elem)&#123;</div><div class="line">    this.push(elem*elem);</div><div class="line">&#125;,out);</div><div class="line">console.log(out); [1,4,9];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Array.prototype.filter();</div><div class="line">1. 返回值:数组,返回给定条件为true的项组成的数组.</div><div class="line">2. 该方法常用于查询符合条件的所有数组项。</div><div class="line">3. 注意:filter()会跳过稀疏数组中缺少的元素,它返回的数组总是稠密的，所以可以用来压缩稀疏数组的空缺</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Array.prototype.some();</div><div class="line">Array.prototype.every();</div><div class="line">1. 返回值。Boolean</div><div class="line">2. some():对数组中的每一项运行给定函数,如果该函数对数组中任意一项返回true,则返回true,否则返回false</div><div class="line">3. every():对数组中的每一项运行给定函数,数组中全部项返回true,则返回true,否则false</div></pre></td></tr></table></figure>
<h4 id="五-检测数组的方法"><a href="#五-检测数组的方法" class="headerlink" title="五.检测数组的方法"></a>五.检测数组的方法</h4> <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">var arr</span> = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>];</div></pre></td></tr></table></figure>
<ol>
<li>console.log(typeof arr); // Object<ul>
<li><code>数组的本质是一种特殊的对象</code>所以返回<code>object</code>,<code>typeof</code>运算符只能用来区分<code>原始类型</code>和<code>对象类型</code>,对于<code>更具体的对象类型是无法鉴别的</code></li>
</ul>
</li>
<li>console.log(arr instanceof Array);// true</li>
</ol>
<ul>
<li><code>instanceof</code>运算符用来判断一个<code>对象是否特定构造函数的实例</code>,如果网页中包含多个框架</li>
</ul>
<ol>
<li>console.log(arr instaceof Object);// true</li>
<li>console.log(Array.isArray(arr));// true</li>
</ol>
<ul>
<li>为了数组检测方便,ES新增了<code>Array.isArray()</code>方法,该方法的目的地是最终确定某个值到底是不是<code>数组</code>,而不管它在那个全局环境中创建的</li>
</ul>
<ol>
<li>console.log(Object.prototype.toString.call(arr) === ‘[Object Array]’;</li>
<li>console.log(Object.prototype.toString.call(arr).slice(8,-1).toLowerCase === ‘array’;</li>
</ol>
<ul>
<li>通过引用<code>Object的toString()</code>方法来检查对象的类属性.</li>
</ul>
<h4 id="六-类数组"><a href="#六-类数组" class="headerlink" title="六.类数组"></a>六.类数组</h4><blockquote>
<p>拥有length属性和对应非负整数属性的对象叫做类数组<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">三类常见的类数组对象。</div><div class="line"><span class="number">1.</span>arguments对象</div><div class="line"><span class="number">2.</span>DOM方法(如document.getElementsByTagName()方法)返回的对象</div><div class="line"><span class="number">3.</span>字符串</div><div class="line">注意:字符串是不可变值，故当把它们作为数组看待时，它们是只读的。如push()、sort()、reverse()、splice()等数组方法会修改数组，它们在字符串上是无效的，且会报错</div><div class="line">数组的slice()方法将类数组对象变成真正的数组</div><div class="line">var arr = Array.prototype.slice.<span class="keyword">call</span>(arrayLike);</div></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="七-ES6-数组的扩展"><a href="#七-ES6-数组的扩展" class="headerlink" title="七.ES6 数组的扩展"></a>七.ES6 数组的扩展</h4><ul>
<li>1.Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">任何有length属性的对象，都可以通过<span class="built_in">Array</span>.from方法转为数组。</div><div class="line"><span class="built_in">Array</span>.from(<span class="string">'hello'</span>)</div><div class="line"><span class="comment">// ['h', 'e', 'l', 'l', 'o']</span></div><div class="line"></div><div class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="comment">// [1, 2, 3]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> namesSet = <span class="keyword">new</span> Set([<span class="string">'a'</span>, <span class="string">'b'</span>])</div><div class="line"><span class="built_in">Array</span>.from(namesSet) <span class="comment">// ['a', 'b']</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);</div><div class="line"><span class="built_in">Array</span>.from(ps).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(p);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.from方法可以将函数的<span class="built_in">arguments</span>对象，转为数组。</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理。</div><div class="line"><span class="built_in">Array</span>.from(arrayLike, <span class="function"><span class="params">x</span> =&gt;</span> x * x);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)</div><div class="line"><span class="comment">// [1, 4, 9]</span></div><div class="line"></div><div class="line">下面的例子将数组中布尔值为<span class="literal">false</span>的成员转为<span class="number">0</span>。</div><div class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, , <span class="number">2</span>, , <span class="number">3</span>], <span class="function">(<span class="params">n</span>) =&gt;</span> n || <span class="number">0</span>)</div><div class="line"><span class="comment">// [1, 0, 2, 0, 3]</span></div><div class="line"></div><div class="line">另一个例子是返回各种数据的类型。</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">typesOf</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, <span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">typeof</span> value)</div><div class="line">&#125;</div><div class="line">typesOf(<span class="literal">null</span>, [], <span class="literal">NaN</span>)</div><div class="line"><span class="comment">// ['object', 'object', 'number']</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>Array.of方法用于将一组值，转换为数组。<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></div><div class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(<span class="number">3</span>) <span class="comment">// [3]</span></div><div class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(<span class="number">3</span>).length <span class="comment">// 1</span></div><div class="line"></div><div class="line">这个方法的主要目的，是弥补数组构造函数<span class="keyword">Array</span>()的不足。</div><div class="line">因为参数个数的不同，会导致<span class="keyword">Array</span>()的行为有差异。</div><div class="line"><span class="keyword">Array</span>() <span class="comment">// []</span></div><div class="line"><span class="keyword">Array</span>(<span class="number">3</span>) <span class="comment">// [undefined, undefined, undefined]</span></div><div class="line"><span class="keyword">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></div><div class="line"><span class="comment">// 只有当参数个数不少于2个，Array()才会返回由参数组成的新数组。</span></div><div class="line"></div><div class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>基本上可以用来替代new <span class="keyword">Array</span>()，</div><div class="line">并且不存在new <span class="keyword">Array</span>(length)导致的重载。它的行为非常统一。</div><div class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>() <span class="comment">// []</span></div><div class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(undefined) <span class="comment">// [undefined]</span></div><div class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(<span class="number">1</span>) <span class="comment">// [1]</span></div><div class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><ol>
<li>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</li>
</ol>
</li>
<li><p>Array.prototype.copyWithin(target, start = 0, end = this.length)<br>它接受三个参数。</p>
</li>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。<br>这三个参数都应该是数值，如果不是，会自动转为数值<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</div><div class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></div><div class="line"></div><div class="line"><span class="comment">// 将3号位复制到0号位</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></div><div class="line"></div><div class="line"><span class="comment">// -2相当于3号位，-1相当于4号位</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-2</span>, <span class="number">-1</span>)</div><div class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></div><div class="line"></div><div class="line"><span class="comment">// 将3号位复制到0号位</span></div><div class="line">[].copyWithin.call(&#123;length: <span class="number">5</span>, <span class="number">3</span>: <span class="number">1</span>&#125;, <span class="number">0</span>, <span class="number">3</span>)</div><div class="line"><span class="comment">// &#123;0: 1, 3: 1, length: 5&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 将2号位到数组结束，复制到0号位</span></div><div class="line"><span class="keyword">var</span> i32a = <span class="function"><span class="keyword">new</span> <span class="title">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span></div><div class="line"><span class="title">i32a</span>.<span class="title">copyWithin</span>(<span class="number">0</span>, <span class="number">2</span>);</div><div class="line"><span class="comment">// Int32Array [3, 4, 5, 4, 5]</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="八-参考来源"><a href="#八-参考来源" class="headerlink" title="八.参考来源"></a>八.参考来源</h4><p><a href="http://www.cnblogs.com/xiaohuochai/p/5682621.html" target="_blank" rel="external">小火柴的蓝色理想：数组的22种方法</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="external">MDN JavaScript标准库Array</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;1.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组：相同数据类型按照一定顺序排列的集合&lt;/li&gt;
&lt;li&gt;稀疏数组：所谓稀疏数组就是数组中大部分的内容值都未被使用(或为零),在数组中仅有少部分的空间使用&lt;/li&gt;
&lt;li&gt;二维数组：二维数组本质上是以数组作为
    
    </summary>
    
      <category term="寄蜉蝣于天地,渺沧海之一粟" scheme="https://double1000.github.io/blog/categories/%E5%AF%84%E8%9C%89%E8%9D%A3%E4%BA%8E%E5%A4%A9%E5%9C%B0-%E6%B8%BA%E6%B2%A7%E6%B5%B7%E4%B9%8B%E4%B8%80%E7%B2%9F/"/>
    
    
      <category term="JavaScript" scheme="https://double1000.github.io/blog/tags/JavaScript/"/>
    
      <category term="Notes" scheme="https://double1000.github.io/blog/tags/Notes/"/>
    
      <category term="数组" scheme="https://double1000.github.io/blog/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
