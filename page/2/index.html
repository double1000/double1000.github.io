<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>岁月如冰河</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="GO SPURS GO" />
  
  
  
  
  <meta name="description" content="热望如鲸歌">
<meta property="og:type" content="website">
<meta property="og:title" content="岁月如冰河">
<meta property="og:url" content="https://double1000.github.io/blog/page/2/index.html">
<meta property="og:site_name" content="岁月如冰河">
<meta property="og:description" content="热望如鲸歌">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="岁月如冰河">
<meta name="twitter:description" content="热望如鲸歌">
  
    <link rel="alternate" href="/atom.xml" title="岁月如冰河" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/home.css" >
  

  

  

</head>



  <body>


  
    <header id="header">

  
    <div id="intrologo" class="intro-logo" style="background-position:center; background-repeat:no-repeat; background-image: url(); background-size: auto 100%;">
    <script>
        var imgUrls = "css/images/home-bg.jpg,http://t.cn/RMbvEza".split(",");
        var random = Math.floor((Math.random() * imgUrls.length ));
        if (imgUrls[random].startsWith('http') || imgUrls[random].indexOf('://') >= 0) {
          document.getElementById("intrologo").style.backgroundImage='url(' + imgUrls[random] + ')';
        } else {
          document.getElementById("intrologo").style.backgroundImage='url(/' + imgUrls[random] + ')';
        }
    </script>
  

    <canvas width="100%" height="100%"></canvas>
    <script>
      var c = document.getElementsByTagName('canvas')[0],
          x = c.getContext('2d'),
          w = window.innerWidth,
          h = window.innerHeight,
          pr = window.devicePixelRatio || 1,
          f = 90,
          q,
          m = Math,
          r = 0,
          u = m.PI*2,
          v = m.cos,
          z = m.random
      c.width = w*pr
      c.height = h*pr
      x.scale(pr, pr)
      x.globalAlpha = 0.6

      
    </script>
    

    
      <div id="homelogo" class="homelogo" style="background: rgba(255,255,255,1);"> 
    

        
          <div class="homelogoback"  style="border: 1px solid #404040;" >
            <h1><a href="#content" id="logo">岁月如冰河</a></h1>
            <h3>热望如鲸歌</h3>
            <h5>胡温柔</h5>
            <!-- <p><a href="https://github.com/iTimeTraveler" target="_blank">Github</a></p> -->
          </div>
        
    
    </div>
  </div>

  <!-- 自适应主页背景大图 -->
  
    <script>
        var img = new Image();
        var intrologodiv = document.getElementById("intrologo");
        img.src = intrologodiv.style.backgroundImage.replace('url(','').replace(')','').replace(/\"/gi, "");
        img.onload=function(){
          if (img.width / img.height <= document.body.clientWidth / document.body.clientHeight) {
            intrologodiv.style.backgroundSize = "100% auto";
          } else {
            intrologodiv.style.backgroundSize = "auto 100%";
          }
        };
    </script>
 

 <!-- home_logo_image居中 -->
 
    <script>
        var homelogodiv = document.getElementById("homelogo");
        if (document.all.homelogo.offsetWidth > document.body.clientWidth) {
          homelogodiv.style.width = document.body.clientWidth + "px";
          homelogodiv.style.marginLeft = document.body.clientWidth * -0.5 + "px";
        } else {
          homelogodiv.style.width = homelogodiv.clientWidth  + "px";
          homelogodiv.style.marginLeft = (homelogodiv.clientWidth)  * -0.5 + "px";
        }
    </script>
  

  <div class="intro-navigate">
      <p class="navigater-list">
        
          <a id="beautifont" class="main-nav-link" href="/">首页</a>
        
          <a id="beautifont" class="main-nav-link" href="/archives">归档</a>
        
          <a id="beautifont" class="main-nav-link" href="/categories">分类</a>
        
          <a id="beautifont" class="main-nav-link" href="/tags">标签</a>
        
          <a id="beautifont" class="main-nav-link" href="/about">关于</a>
        
      </p>
  </div>

</header>
  
  <div id="container">
    <div id="wrap">
      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;">
  
    <article id="post-web-前端相关名字以及解释"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/12/web-前端相关名字以及解释/">web | 前端相关术语</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/12/web-前端相关名字以及解释/" class="article-date">
	  <time datetime="2017-04-12T04:58:11.000Z" itemprop="datePublished">2017-04-12</time>
	</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>组件化,同步跟异步,阻塞与非阻塞…..</p>
<ul>
<li>组件化<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">组件化就是基于可重用的目的，将一个大的软件系统按照分离关注点的形式，</div><div class="line">拆分成多个独立的组件，主要目的就是减少耦合。</div><div class="line">一个独立的组件可以是一个软件包、web服务、web资源或者是封装了一些函数的模块。</div><div class="line">这样，独立出来的组件可以单独维护和升级而不会影响到其他的组件。</div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://www.zhihu.com/question/29735633" target="_blank" rel="external">知乎:什么叫组件化开发</a></p>
<ul>
<li>模块化<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">模块化的目的在于将一个程序按照其功能做拆分，分成相互独立的模块，</div><div class="line">便于每个模块只包含与其功能相关的内容，模块之间通过接口调用。</div><div class="line">将一个大的系统模块化之后，每个模块都可以被高度复用。</div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://www.zhihu.com/question/37649318" target="_blank" rel="external">知乎:前端开发的模块化和组件化的定义，以及两者的关系</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">模块化的目的是为了重用，模块化后可以方便重复使用和插拨到不同的平台，不同的业务逻辑过程中。</div><div class="line">组件化的目的是为了解耦，把系统拆分成多个组件，分离组件边界和责任，便于独立升级和维护。</div></pre></td></tr></table></figure>
<ul>
<li>同步跟异步<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">同步是阻塞模式，异步是非阻塞模式。 </div><div class="line">同步是指两个线程的运行是相关的，其中一个线程要阻塞等待另外一个线程的运行。</div><div class="line">异步的意思是两个线程毫无相关，自己运行自己的。 </div><div class="line"></div><div class="line">同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。 </div><div class="line">异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://segmentfault.com/a/1190000004322358#articleHeader1" target="_blank" rel="external">彻底理解同步、异步和事件循环(Event Loop)</a><br><a href="http://blog.csdn.net/u013063153/article/details/52457307" target="_blank" rel="external">深入理解JavaScript编程中的同步与异步机制</a></p>
<ul>
<li>阻塞与非阻塞<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。</div><div class="line">阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</div><div class="line">非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</div><div class="line"></div><div class="line">示例：</div><div class="line">以打电话让书店老板查找某本书为例来讲：</div><div class="line">同步通信机制：老板说，“你稍等，我查下”，然后查好后（可能会<span class="number">5</span>秒或者<span class="number">1</span>天）告诉你结果（返回结果）。</div><div class="line">异步通信机制：老板说，“我查好后打电话你”，然后直接挂电话（无返回结果）。查好后打电话你（“回电”这种方式回调/通知你）。</div><div class="line">阻塞式调用：打电话给老板时，你会一直把自己“挂起”，直到结果返回。</div><div class="line">非阻塞式调用：打电话给老板时，不管老板有没有告诉你，你自己先一边玩了，但可能会每过几分钟跟老板check一下有没有返回结果。</div><div class="line"></div><div class="line">总结：阻塞与非阻塞 与 是否同步异步无关（跟老板通过什么方式回答你无关）。</div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://github.com/creeperyang/blog/issues/15" target="_blank" rel="external">编程资源（概念解释/优秀博文/其它)</a><br><a href="https://www.zhihu.com/question/19732473/answer/20851256" target="_blank" rel="external">知乎:怎样理解阻塞非阻塞与同步异步的区别？</a></p>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WEB/">WEB</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/object-Object/">[object Object]</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/协议-标准/">协议/标准</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/寄蜉蝣于天地-渺沧海之一粟/">寄蜉蝣于天地,渺沧海之一粟</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-http-前端开发工程师应该知道的http协议知识"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/12/http-前端开发工程师应该知道的http协议知识/">HTTP | 前端开发工程师应该知道的HTTP协议知识</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/12/http-前端开发工程师应该知道的http协议知识/" class="article-date">
	  <time datetime="2017-04-12T00:40:31.000Z" itemprop="datePublished">2017-04-12</time>
	</a>

      
    <a class="article-category-link" href="/categories/寄蜉蝣于天地-渺沧海之一粟/">寄蜉蝣于天地,渺沧海之一粟</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h3><p><a href="https://www.wikiwand.com/zh/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">维基百科</a><br><a href="http://xiaotank.blog.51cto.com/2461521/1191420" target="_blank" rel="external">HTTP详解</a><br><a href="http://www.imooc.com/article/14281" target="_blank" rel="external">从访问网页简单理解互联网数据交换的整个过程</a><br><a href="http://www.imooc.com/article/14397" target="_blank" rel="external">前端开发工程师应该知道的http协议知识</a></p>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/协议-标准/">协议/标准</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-javascript-notes-作用域和闭包"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/09/javascript-notes-作用域和闭包/">JavaScript Notes | 作用域和闭包</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/09/javascript-notes-作用域和闭包/" class="article-date">
	  <time datetime="2017-04-09T11:58:50.000Z" itemprop="datePublished">2017-04-09</time>
	</a>

      
    <a class="article-category-link" href="/categories/寄蜉蝣于天地-渺沧海之一粟/">寄蜉蝣于天地,渺沧海之一粟</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="1.jpg"></p>
<h1 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h1><p>作用域和闭包是 JavaScript 最重要的概念之一，想要进一步学习 JavaScript，就必须理解 JavaScript 作用域和闭包的工作原理。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在 JavaScript 中，变量的作用域有全局作用域和局部作用域两种。</p>
<h3 id="全局作用域（Global-Scope）"><a href="#全局作用域（Global-Scope）" class="headerlink" title="全局作用域（Global Scope）"></a>全局作用域（Global Scope）</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下三种情形拥有全局作用域：</p>
<p>1.最外层函数和在最外层函数外面定义的变量拥有全局作用域，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> global = <span class="string">"global"</span>;     <span class="comment">// 显式声明一个全局变量</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> local = <span class="string">"local"</span>;   <span class="comment">// 显式声明一个局部变量</span></div><div class="line">    <span class="keyword">return</span> global;         <span class="comment">// 返回全局变量的值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(global);       <span class="comment">// "global"</span></div><div class="line"><span class="built_in">console</span>.log(checkscope()); <span class="comment">// "global"</span></div><div class="line"><span class="built_in">console</span>.log(local);        <span class="comment">// error: local is not defined.</span></div></pre></td></tr></table></figure>
<p>上面代码中，<code>global</code> 是全局变量，不管是在 <code>checkscope()</code> 函数内部还是外部，都能访问到全局变量 <code>global</code>。</p>
<p>2.所有末定义直接赋值的变量自动声明为拥有全局作用域，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> local = <span class="string">"local"</span>; <span class="comment">// 显式声明一个局部变量</span></div><div class="line">    global = <span class="string">"global"</span>;   <span class="comment">// 隐式声明一个全局变量(不好的写法)</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(global);     <span class="comment">// "global"</span></div><div class="line"><span class="built_in">console</span>.log(local);      <span class="comment">// error: local is not defined.</span></div></pre></td></tr></table></figure>
<p>上面代码中，变量 <code>global</code> 未用 <code>var</code> 关键字定义就直接赋值，所以隐式的创建了全局变量 <code>global</code>，但这种写法容易造成误解，应尽量避免这种写法。</p>
<p>3.所有 <code>window</code> 对象的属性拥有全局作用域</p>
<p>一般情况下，<code>window</code> 对象的内置属性都拥有全局作用域，例如 <code>window.name</code>、<code>window.location</code>、<code>window.top</code> 等等。</p>
<h3 id="局部作用域（Local-Scope）"><a href="#局部作用域（Local-Scope）" class="headerlink" title="局部作用域（Local Scope）"></a>局部作用域（Local Scope）</h3><p>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到。最常见的是在函数体内定义的变量，只能在函数体内使用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> local = <span class="string">"local"</span>;   <span class="comment">// 显式声明一个局部变量</span></div><div class="line">    <span class="keyword">return</span> local;         <span class="comment">// 返回全局变量的值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(checkscope()); <span class="comment">// "local"</span></div><div class="line"><span class="built_in">console</span>.log(local);        <span class="comment">// error: local is not defined.</span></div></pre></td></tr></table></figure>
<p>上面代码中，在函数体内定义了变量 <code>local</code>，在函数体内是可以访问了，在函数外访问就报错了。</p>
<h3 id="全局和局部作用域的关系"><a href="#全局和局部作用域的关系" class="headerlink" title="全局和局部作用域的关系"></a>全局和局部作用域的关系</h3><p>在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所遮盖。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;      <span class="comment">// 声明一个全局变量</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local"</span>;   <span class="comment">// 声明一个同名的局部变量</span></div><div class="line">    <span class="keyword">return</span> scope;          <span class="comment">// 返回局部变量的值，而不是全局变量的值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(checkscope()); <span class="comment">// "local"</span></div></pre></td></tr></table></figure>
<p>尽管在全局作用域编写代码时可以不写 <code>var</code> 语句，但声明局部变量时则必须使用 <code>var</code> 语句。思考一下如果不这样做会怎样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">scope = <span class="string">"global"</span>;           <span class="comment">// 声明一个全局变量，甚至不用 var 来声明</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    scope = <span class="string">"local"</span>;        <span class="comment">// 糟糕！我们刚修改了全局变量</span></div><div class="line">    myscope = <span class="string">"local"</span>;      <span class="comment">// 这里显式地声明了一个新的全局变量</span></div><div class="line">    <span class="keyword">return</span> [scope, myscope];<span class="comment">// 返回两个值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(checkscope2()); <span class="comment">// ["local", "local"]，产生了副作用</span></div><div class="line"><span class="built_in">console</span>.log(scope);         <span class="comment">// "local"，全局变量修改了</span></div><div class="line"><span class="built_in">console</span>.log(myscope);       <span class="comment">// "local"，全局命名空间搞乱了</span></div></pre></td></tr></table></figure>
<p>函数定义是可以嵌套的。由于每个函数都有它自己的作用域，因此会出现几个局部作用域嵌套的情况，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;         <span class="comment">// 全局变量</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;      <span class="comment">//局部变量 </span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">nested</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> scope = <span class="string">"nested scope"</span>; <span class="comment">// 嵌套作用域内的局部变量</span></div><div class="line">        <span class="keyword">return</span> scope;               <span class="comment">// 返回当前作用域内的值</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> nested();</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(checkscope());          <span class="comment">// "nested scope"</span></div></pre></td></tr></table></figure>
<h3 id="函数作用域和声明提前"><a href="#函数作用域和声明提前" class="headerlink" title="函数作用域和声明提前"></a>函数作用域和声明提前</h3><p>在一些类似 C 语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，我们称为块级作用域（block scope），而 JavaScript 中没有块级作用域。JavaScript 取而代之地使用了函数作用域（function scope），变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。</p>
<p>在如下所示的代码中，在不同位置定义了变量 <code>i</code>、<code>j</code> 和 <code>k</code>，它们都在同一个作用域内，这三个变量在函数体内均是有定义的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>; <span class="comment">// i在整个函数体内均是有定义的</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> o == <span class="string">"object"</span>) &#123;</div><div class="line">        <span class="keyword">var</span> j = <span class="number">0</span>; <span class="comment">// j在函数体内是有定义的，不仅仅是在这个代码段内</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123; <span class="comment">// k在函数体内是有定义的，不仅仅是在循环内</span></div><div class="line">            <span class="built_in">console</span>.log(k); <span class="comment">// 输出数字0~9</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.log(k); <span class="comment">// k已经定义了，输出10</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(j); <span class="comment">// j已经定义了，但可能没有初始化</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JavaScript 的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至已经可用。JavaScript 的这个特性被非正式地称为声明提前（hoisting），即 JavaScript 函数里声明的所有变量（但不涉及赋值）都被「提前」至函数体的顶部，看一下如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(scope);  <span class="comment">// 输出"undefined"，而不是"global"</span></div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local"</span>; <span class="comment">// 变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的</span></div><div class="line">    <span class="built_in">console</span>.log(scope);  <span class="comment">// 输出"local"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可能会误以为函数中的第一行会输出 <code>&quot;global&quot;</code>，因为代码还没有执行到 <code>var</code> 语句声明局部变量的地方。其实不然，由于函数作用域的特性，局部变量在整个函数体始终是有定义的，也就是说，在函数体内局部变量遮盖了同名全局变量。尽管如此，只有在程序执行到 <code>var</code> 语句的时候，局部变量才会被真正赋值。因此，上述过程等价于：将函数内的变量声明“提前”至函数体顶部，同时变量初始化留在原来的位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope;          <span class="comment">// 在函数顶部声明了局部变量</span></div><div class="line">    <span class="built_in">console</span>.log(scope); <span class="comment">// 变量存在，但其值是"undefined"</span></div><div class="line">    scope = <span class="string">"local"</span>;    <span class="comment">// 这里将其初始化并赋值</span></div><div class="line">    <span class="built_in">console</span>.log(scope); <span class="comment">// 这里它具有了我们所期望的值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在具有块级作用域的编程语言中，在狭小的作用域里让变量声明和使用变量的代码尽可能靠近彼此，通常来讲，这是一个非常不错的编程习惯。由于 JavaScript 没有块级作用域，因此一些程序员特意将变量声明放在函数体顶部，而不是将声明靠近放在使用变量之处。这种做法使得他们的源代码非常清晰地反映了真实的变量作用域。</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其<strong>活动对象</strong>（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 <code>arguments</code> 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。</p>
<p>请看下面的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (color === <span class="string">"blue"</span>)&#123;</div><div class="line">        color = <span class="string">"red"</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        color = <span class="string">"blue"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(changeColor());</div></pre></td></tr></table></figure>
<p>在这个简单的例子中，函数 <code>changeColor()</code> 的作用域链包含两个对象：它自己的变量对象（其中定义着 <code>arguments</code> 对象）和全局环境的变量对象。可以在函数内部访问变量 <code>color</code>，就是因为可以在这个作用域链中找到它。</p>
<p>此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面这个例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> tempColor = anotherColor;</div><div class="line">        anotherColor = color;</div><div class="line">        color = tempColor;</div><div class="line"></div><div class="line">        <span class="comment">// 这里可以访问color、anotherColor和tempColor</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这里可以访问color和anotherColor，但不能访问tempColor</span></div><div class="line">    swapColors();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这里只能访问color</span></div><div class="line">changeColor();</div></pre></td></tr></table></figure>
<p>以上代码共涉及3个执行环境：全局环境、<code>changeColor()</code> 的局部环境和 <code>swapColors()</code> 的局部环境。全局环境中有一个变量 <code>color</code> 和一个函数 <code>changeColor()</code>。<code>changeColor()</code> 的局部环境中有一个名为 <code>anotherColor</code> 的变量和一个名为 <code>swapColors()</code> 的函数，但它也可以访问全局环境中的变量 <code>color</code>。<code>swapColors()</code> 的局部环境中有一个变量 <code>tempColor</code>，该变量只能在这个环境中访问到。无论全局环境还是 <code>changeColor()</code> 的局部环境都无权访问 <code>tempColor</code>。然而，在 <code>swapColors()</code> 内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。下图形象地展示了前面这个例子的作用域链。</p>
<p><img src="http://qiniu.shijiajie.com/blog/javascript-lesson/2.41.jpg" alt=""></p>
<p>上图中的矩形表示特定的执行环境。其中，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。对于这个例子中的 <code>swapColors()</code> 而言，其作用域链中包含3个对象：<code>swapColors()</code> 的变量对象、<code>changeColor()</code> 的变量对象和全局变量对象。<code>swapColors()</code> 的局部环境开始时会先在自己的变量对象中搜索变量和函数名，如果搜索不到则再搜索上一级作用域链。<code>changeColor()</code> 的作用域链中只包含两个对象：它自己的变量对象和全局变量对象。这也就是说，它不能访问 <code>swapColors()</code> 的环境。函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>MDN 对闭包的定义：</p>
<blockquote>
<p>闭包是指那些能够访问独立（自由）变量的函数（变量在本地使用，但定义在一个封闭的作用域中）。换句话说，这些函数可以「记忆」它被创建时候的环境。</p>
</blockquote>
<p>《JavaScript 权威指南(第6版)》对闭包的定义：</p>
<blockquote>
<p>函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为闭包。</p>
</blockquote>
<p>《JavaScript 高级程序设计(第3版)》对闭包的定义：</p>
<blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>
</blockquote>
<p>上面这些定义都比较晦涩难懂，<a href="http://www.ruanyifeng.com/" target="_blank" rel="external">阮一峰</a>的解释稍微好理解一些：</p>
<blockquote>
<p>由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成定义在一个函数内部的函数。</p>
</blockquote>
<h3 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h3><p>闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量（作用域链），另一个就是让这些变量的值始终保持在内存中。怎么来理解这句话呢？请看下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;　　　</div><div class="line">    <span class="keyword">var</span> n = <span class="number">1</span>;</div><div class="line"></div><div class="line">    add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        n += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(n);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fun2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = fun();　　</div><div class="line">result(); <span class="comment">// 1</span></div><div class="line">add();</div><div class="line">result(); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>在这段代码中，<code>result</code> 实际上就是函数 <code>fun2</code>。它一共运行了两次，第一次的值是 <code>1</code>，第二次的值是 <code>2</code>。这证明了，函数 <code>fun</code> 中的局部变量 <code>n</code> 一直保存在内存中，并没有在 <code>fun</code> 调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于 <code>fun</code> 是 <code>fun2</code> 的父函数，而 <code>fun2</code> 被赋给了一个全局变量，这导致 <code>fun2</code> 始终在内存中，而 <code>fun2</code> 的存在依赖于 <code>fun</code>，因此 <code>fun</code> 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<p>这段代码中另一个值得注意的地方，就是 <code>add = function() { n += 1 }</code> 这一行。首先，变量 <code>add</code> 前面没有使用 <code>var</code> 关键字，因此 <code>add</code> 是一个全局变量，而不是局部变量。其次，<code>add</code> 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，和 <code>fun2</code> 处于同一作用域，所以 <code>add</code> 相当于是一个 <code>setter</code>，可以在函数外部对函数内部的局部变量进行操作。</p>
<h3 id="计数器的困境"><a href="#计数器的困境" class="headerlink" title="计数器的困境"></a>计数器的困境</h3><p>我们再来看一个经典例子「计数器的困境」，假设你想统计一些数值，且该计数器在所有函数中都是可用的。你可以定义一个全局变量 <code>counter</code> 当做计数器，再定义一个 <code>add()</code> 函数来设置计数器递增。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> counter += <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="comment">// 计数器现在为 3</span></div></pre></td></tr></table></figure>
<p>计数器数值在执行 <code>add()</code> 函数时发生变化。但问题来了，页面上的任何脚本都能改变计数器 <code>counter</code>，即便没有调用 <code>add()</code> 函数。如果我们将计数器 <code>counter</code> 定义在 <code>add()</code> 函数内部，就不会被外部脚本随意修改到计数器的值了。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> counter += <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="comment">// 本意是想输出 3, 但事与愿违，输出的都是 1</span></div></pre></td></tr></table></figure>
<p>因为每次调用 <code>add()</code> 函数，计数器都会被重置为 0，输出的都是 1，这并不是我们想要的结果。闭包正好可以解决这个问题，我们在 <code>add()</code> 函数内部，再定义一个 <code>plus()</code> 内嵌函数（闭包），内嵌函数 <code>plus()</code> 可以访问父函数的 <code>counter</code> 变量。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> plus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;counter += <span class="number">1</span>;&#125;</div><div class="line">    plus();</div><div class="line">    <span class="keyword">return</span> counter; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，只要我们能在外部访问 <code>plus()</code> 函数，并且确保 <code>counter = 0</code> 只执行一次，就能解决计数器的困境。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> plus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> counter += <span class="number">1</span>;&#125;</div><div class="line">    <span class="keyword">return</span> plus;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> puls2 = add();</div><div class="line"><span class="built_in">console</span>.log(puls2());</div><div class="line"><span class="built_in">console</span>.log(puls2());</div><div class="line"><span class="built_in">console</span>.log(puls2());</div><div class="line"><span class="comment">// 计数器为 3</span></div></pre></td></tr></table></figure>
<p>计数器 <code>counter</code> 受 <code>add()</code> 函数的作用域保护，只能通过 <code>puls2</code> 方法修改。</p>
<h3 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h3><ul>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除或设置为 <code>null</code>，断开变量和内存的联系。</li>
<li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（public method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>
</ul>
<p>JavaScript 闭包是一种强大的语言特性。通过使用这个语言特性来隐藏变量，可以避免覆盖其他地方使用的同名变量，理解闭包有助于编写出更有效也更简洁的代码。</p>
<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a><code>this</code> 关键字</h2><p>谈到作用域和闭包就不得不说 <code>this</code> 关键字，虽然它们之间关联不大，但是它们一起使用却容易让人产生疑惑。下面列出了使用 <code>this</code> 的大部分场景，带大家一探究竟。</p>
<p><code>this</code> 是 JavaScript 的关键字，指函数执行时的上下文，跟函数定义时的上下文无关。随着函数使用场合的不同，<code>this</code> 的值会发生变化。但是有一个总的原则，那就是 <code>this</code> 指代的是调用函数的那个对象。</p>
<h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>在全局上下文中，也就是在任何函数体外部，<code>this</code> 指代全局对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在浏览器中，this 指代全局对象 window</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>在函数上下文中，也就是在任何函数体内部，<code>this</code> 指代调用函数的那个对象。</p>
<h4 id="函数调用中的-this"><a href="#函数调用中的-this" class="headerlink" title="函数调用中的 this"></a>函数调用中的 <code>this</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(f1() === <span class="built_in">window</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>如上代码所示，直接定义一个函数 <code>f1()</code>，相当于为 <code>window</code> 对象定义了一个属性。直接执行函数 <code>f1()</code>，相当于执行 <code>window.f1()</code>。所以函数 <code>f1()</code> 中的 <code>this</code> 指代调用函数的那个对象，也就是 <code>window</code> 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>; <span class="comment">// 这里是严格模式</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(f2() === <span class="literal">undefined</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>如上代码所示，在「严格模式」下，禁止 <code>this</code> 关键字指向全局对象（在浏览器环境中也就是 <code>window</code> 对象），<code>this</code> 的值将维持 <code>undefined</code> 状态。</p>
<h4 id="对象方法中的-this"><a href="#对象方法中的-this" class="headerlink" title="对象方法中的 this"></a>对象方法中的 <code>this</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"stone"</span>,</div><div class="line">    <span class="attr">f</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// "stone"</span></div></pre></td></tr></table></figure>
<p>如上代码所示，对象 <code>o</code> 中包含一个属性 <code>name</code> 和一个方法 <code>f()</code>。当我们执行 <code>o.f()</code> 时，方法 <code>f()</code> 中的 <code>this</code> 指代调用函数的那个对象，也就是对象 <code>o</code>，所以 <code>this.name</code> 也就是 <code>o.name</code>。</p>
<p>注意，在何处定义函数完全不会影响到 <code>this</code> 的行为，我们也可以首先定义函数，然后再将其附属到 <code>o.f</code>。这样做 <code>this</code> 的行为也一致。如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">name</span>: <span class="string">"stone"</span> &#125;;</div><div class="line">o.f = fun;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// "stone"</span></div></pre></td></tr></table></figure>
<p>类似的，<code>this</code> 的绑定只受最靠近的成员引用的影响。在下面的这个例子中，我们把一个方法 <code>g()</code> 当作对象 <code>o.b</code> 的函数调用。在这次执行期间，函数中的 <code>this</code> 将指向 <code>o.b</code>。事实上，这与对象本身的成员没有多大关系，最靠近的引用才是最重要的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">o.b = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"sophie"</span></div><div class="line">    g: fun,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.b.g()); <span class="comment">// "sophie"</span></div></pre></td></tr></table></figure>
<h4 id="eval-方法中的-this"><a href="#eval-方法中的-this" class="headerlink" title="eval() 方法中的 this"></a><code>eval()</code> 方法中的 <code>this</code></h4><p><code>eval()</code> 方法可以将字符串转换为 JavaScript 代码，使用 <code>eval()</code> 方法时，<code>this</code> 指向哪里呢？答案很简单，看谁在调用 <code>eval()</code> 方法，调用者的执行环境中的 <code>this</code> 就被 <code>eval()</code> 方法继承下来了。如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局上下文</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">"this"</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(f1() === <span class="built_in">window</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 函数上下文</span></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"stone"</span>,</div><div class="line">    <span class="attr">f</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">"this.name"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// "stone"</span></div></pre></td></tr></table></figure>
<h4 id="call-和-apply-方法中的-this"><a href="#call-和-apply-方法中的-this" class="headerlink" title="call() 和 apply() 方法中的 this"></a><code>call()</code> 和 <code>apply()</code> 方法中的 <code>this</code></h4><p><code>call()</code> 和 <code>apply()</code> 是函数对象的方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，<code>this</code> 指代的就是这两个方法的第一个参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">0</span>;　　</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;　　　　</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);　　</div><div class="line">&#125;　　</div><div class="line"><span class="keyword">var</span> o = &#123;&#125;;　　</div><div class="line">o.x = <span class="number">1</span>;</div><div class="line">o.m = f;　　</div><div class="line">o.m.apply(); <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p><code>call()</code> 和 <code>apply()</code> 的参数为空时，默认调用全局对象。因此，这时的运行结果为 <code>0</code>，证明 <code>this</code> 指的是全局对象。如果把最后一行代码修改为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">o.m.apply(o); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>运行结果就变成了 <code>1</code>，证明了这时 <code>this</code> 指代的是对象 <code>o</code>。</p>
<h4 id="bind-方法中的-this"><a href="#bind-方法中的-this" class="headerlink" title="bind() 方法中的 this"></a><code>bind()</code> 方法中的 <code>this</code></h4><p>ECMAScript 5 引入了 <code>Function.prototype.bind</code>。调用 <code>f.bind(someObject)</code> 会创建一个与 <code>f</code> 具有相同函数体和作用域的函数，但是在这个新函数中，<code>this</code> 将永久地被绑定到了 <code>bind</code> 的第一个参数，无论这个函数是如何被调用的。如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = f.bind(&#123;</div><div class="line">    <span class="attr">a</span>: <span class="string">"stone"</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// stone</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">28</span>,</div><div class="line">    <span class="attr">f</span>: f,</div><div class="line">    <span class="attr">g</span>: g</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(o.f(), o.g()); <span class="comment">// 28, stone</span></div></pre></td></tr></table></figure>
<h4 id="DOM-事件处理函数中的-this"><a href="#DOM-事件处理函数中的-this" class="headerlink" title="DOM 事件处理函数中的 this"></a>DOM 事件处理函数中的 <code>this</code></h4><p>一般来讲，当函数使用 <code>addEventListener</code>，被用作事件处理函数时，它的 <code>this</code> 指向触发事件的元素。如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</div><div class="line">        btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">this</span>.style.backgroundColor = <span class="string">"#A5D9F3"</span>;</div><div class="line">        &#125;, <span class="literal">false</span>);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>但在 IE 浏览器中，当函数使用 <code>attachEvent</code> ，被用作事件处理函数时，它的 <code>this</code> 却指向 <code>window</code>。如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</div><div class="line">        btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);  <span class="comment">// true</span></div><div class="line">        &#125;);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="内联事件处理函数中的-this"><a href="#内联事件处理函数中的-this" class="headerlink" title="内联事件处理函数中的 this"></a>内联事件处理函数中的 <code>this</code></h4><p>当代码被内联处理函数调用时，它的 <code>this</code> 指向监听器所在的 DOM 元素。如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert(this.tagName.toLowerCase());"</span>&gt;</span></div><div class="line">  Show this</div><div class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面的 <code>alert</code> 会显示 <code>button</code>，注意只有外层代码中的 <code>this</code> 是这样设置的。如果 <code>this</code> 被包含在匿名函数中，则又是另外一种情况了。如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert((function()&#123;return this&#125;)());"</span>&gt;</span></div><div class="line">  Show inner this</div><div class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在这种情况下，<code>this</code> 被包含在匿名函数中，相当于处于全局上下文中，所以它指向 <code>window</code> 对象。</p>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Notes/">Notes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/作用域/">作用域</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/闭包/">闭包</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-web-开发流程环节"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/06/web-开发流程环节/">web | 开发流程环节/名词/规范</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/06/web-开发流程环节/" class="article-date">
	  <time datetime="2017-04-06T07:30:17.000Z" itemprop="datePublished">2017-04-06</time>
	</a>

      
    <a class="article-category-link" href="/categories/寄蜉蝣于天地-渺沧海之一粟/">寄蜉蝣于天地,渺沧海之一粟</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="1.jpg"></p>
<h4 id="一-相关名词解释"><a href="#一-相关名词解释" class="headerlink" title="一.相关名词解释"></a>一.相关名词解释</h4><ol>
<li>运维工程师 （代码部署工程服务） OP</li>
<li>产品经理  PM （ProductManager) 对产品负责</li>
<li>MRD 产出 市场需求文档 对产品复杂分析</li>
<li>UI UserInterface 界面视觉设计</li>
<li>UE UserExperience 用户体验设计</li>
<li>技术经理 PM (PojectManager)</li>
<li>项目管理员,对项目负责</li>
<li>前端开发 FE - FrontEnd developer engineer</li>
<li>后端开发 RD</li>
<li>测试 QA</li>
</ol>
<h4 id="二-WEB开发流程"><a href="#二-WEB开发流程" class="headerlink" title="二.WEB开发流程"></a>二.WEB开发流程</h4><h5 id="2-1-需求确定"><a href="#2-1-需求确定" class="headerlink" title="2-1. 需求确定"></a>2-1. 需求确定</h5><h5 id="2-2-分析与设计"><a href="#2-2-分析与设计" class="headerlink" title="2-2. 分析与设计"></a>2-2. 分析与设计</h5><h6 id="2-2-1-架构分析与设计"><a href="#2-2-1-架构分析与设计" class="headerlink" title="2-2.1. 架构分析与设计"></a>2-2.1. 架构分析与设计</h6><h6 id="2-2-2-业务逻辑分析"><a href="#2-2-2-业务逻辑分析" class="headerlink" title="2-2.2. 业务逻辑分析"></a>2-2.2. 业务逻辑分析</h6><h6 id="2-2-3-业务逻辑设计"><a href="#2-2-3-业务逻辑设计" class="headerlink" title="2-2.3. 业务逻辑设计"></a>2-2.3. 业务逻辑设计</h6><h6 id="2-2-4-界面设计"><a href="#2-2-4-界面设计" class="headerlink" title="2-2.4. 界面设计"></a>2-2.4. 界面设计</h6><h5 id="2-3-开发环境搭建"><a href="#2-3-开发环境搭建" class="headerlink" title="2-3. 开发环境搭建"></a>2-3. 开发环境搭建</h5><h5 id="2-4-开发-测试-开发-测试"><a href="#2-4-开发-测试-开发-测试" class="headerlink" title="2-4. 开发-测试-开发-测试"></a>2-4. 开发-测试-开发-测试</h5><h5 id="2-5-文档编纂"><a href="#2-5-文档编纂" class="headerlink" title="2-5. 文档编纂"></a>2-5. 文档编纂</h5><h4 id="三-WEB开发环节"><a href="#三-WEB开发环节" class="headerlink" title="三.WEB开发环节"></a>三.WEB开发环节</h4><ul>
<li><p>开发前</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">产品功能设计</div><div class="line">视觉 最终效果 （ 产品经理）</div><div class="line">视觉/交互设计 交互 操作流程（美工）</div></pre></td></tr></table></figure>
</li>
<li><p>开发中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">技术规划</div><div class="line">考虑产品需求是否合理</div><div class="line">产品代码是否可以复用</div><div class="line">复杂项目是否可以拆分  （技术经理）</div></pre></td></tr></table></figure>
</li>
<li><p>开发后</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">测试 （测试工程师QA 对网页代码进行 功能/性能测试）</div><div class="line">上线</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="四-WEB开发文档"><a href="#四-WEB开发文档" class="headerlink" title="四.WEB开发文档"></a>四.WEB开发文档</h4><h5 id="1-需求文档-MRD-描述项目功能需求"><a href="#1-需求文档-MRD-描述项目功能需求" class="headerlink" title="1.需求文档 MRD  描述项目功能需求"></a>1.需求文档 MRD  描述项目功能需求</h5><h5 id="2-项目开发文档-技术经理负责"><a href="#2-项目开发文档-技术经理负责" class="headerlink" title="2.项目开发文档 技术经理负责"></a>2.项目开发文档 技术经理负责</h5><ol>
<li>可行性确认</li>
<li>技术选型</li>
<li>开发/线上坏境规划</li>
<li>技术开发方案设计</li>
<li>团队协作方式</li>
</ol>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WEB/">WEB</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/协议-标准/">协议/标准</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发流程/">开发流程</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-javascript-notes-json"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2017/04/06/javascript-notes-json/">JavaScript Notes | JSON</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/04/06/javascript-notes-json/" class="article-date">
	  <time datetime="2017-04-06T06:23:54.000Z" itemprop="datePublished">2017-04-06</time>
	</a>

      
    <a class="article-category-link" href="/categories/寄蜉蝣于天地-渺沧海之一粟/">寄蜉蝣于天地,渺沧海之一粟</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="1.jpg"></p>
<ul>
<li>json(javascript object notaion)全称是javascript对象表示法,它是一种数据交换的文本格式,而不是一种数据交换的文本格式,而不是一种编程语言,用于读取结构化数据,JSON是设计成描述数据交换格式的，他也有自己的语法，这个语法是JavaScript的一个子集。</li>
</ul>
<h5 id="一-语法规则"><a href="#一-语法规则" class="headerlink" title="一. 语法规则"></a>一. 语法规则</h5><ol>
<li>JSON的语法可以表示以下三种类型的值。字符串,数值,布尔值,和null</li>
<li>字符串必须使用双引号表示,不能使用单引号,数值必须使用十进制,且不能使用NaN和Infinity</li>
<li>JSON不支持javascript中的特殊值undefined<h5 id="二-JSON与对象-数组的区别"><a href="#二-JSON与对象-数组的区别" class="headerlink" title="二. JSON与对象,数组的区别"></a>二. JSON与对象,数组的区别</h5></li>
<li>对象和数组都是作为一种复杂数据类型,表示的是一组有序的键值对儿</li>
<li>对象的每个键值对儿中的值可以是简单值,也可以是复杂数据类型的值</li>
<li>数组表示一组有序的值的列表可以通过数值索引来访问其中的值,数组的值可以是任意类型 – 简单值,对象,或数组</li>
<li>注意:数组或对象最后一个成员的后面,不能加逗号.</li>
<li>JSON不支持JavaScript中的特殊值undefined</li>
<li>JSON没有变量的概念</li>
<li>JSON中,对象的键名必须放在双引号里面</li>
<li>因为JSON不是JavaScript语句,所以没有末尾的分号<h5 id="三-JSON对象stringify-方法"><a href="#三-JSON对象stringify-方法" class="headerlink" title="三.JSON对象stringify()方法"></a>三.JSON对象stringify()方法</h5><h6 id="3-1-JSON-stringify-把javascript对象序列化"><a href="#3-1-JSON-stringify-把javascript对象序列化" class="headerlink" title="3-1. JSON.stringify();把javascript对象序列化"></a>3-1. JSON.stringify();<code>把javascript对象序列化</code></h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jsonobj = &#123;</div><div class="line">    <span class="string">"title"</span>:<span class="string">"javascript"</span>,</div><div class="line">    <span class="string">"group"</span>:&#123;</div><div class="line">        <span class="string">"name"</span>:<span class="string">"jia"</span>,</div><div class="line">        <span class="string">"tel"</span>:<span class="number">12345</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> jsonstringify = <span class="built_in">JSON</span>.stringify(jsonobj);</div><div class="line"><span class="comment">//&#123;"title":"javascript","group":&#123;"name":"jia","tel":12345&#125;&#125;</span></div><div class="line"></div><div class="line">如果对象的成员是<span class="literal">undefined</span>或函数，这个成员会被省略</div><div class="line">如果数组的成员是<span class="literal">undefined</span>或函数，则这些值被转成<span class="literal">null</span></div><div class="line"><span class="built_in">JSON</span>.stringify(&#123;</div><div class="line">  <span class="attr">a</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line">  <span class="attr">b</span>: <span class="literal">undefined</span>,</div><div class="line">  <span class="attr">c</span>: [ <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="literal">undefined</span> ]</div><div class="line">&#125;);</div><div class="line"><span class="comment">// "&#123;"c":[null,null]&#125;"</span></div><div class="line"></div><div class="line">stringify()方法把正则表达式和数学对象转换成空对象的字符串形式</div><div class="line"><span class="built_in">JSON</span>.stringify(<span class="regexp">/foo/</span>) <span class="comment">// "&#123;&#125;"</span></div><div class="line"><span class="built_in">JSON</span>.stringify(<span class="built_in">Math</span>) <span class="comment">// "&#123;&#125;"</span></div><div class="line"></div><div class="line">stringify()方法把日期对象和包装对象转换成字符串</div><div class="line"><span class="built_in">JSON</span>.stringify(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>)) <span class="comment">//"true"</span></div><div class="line"><span class="built_in">JSON</span>.stringify(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'123'</span>)) <span class="comment">//""123""</span></div><div class="line"><span class="built_in">JSON</span>.stringify(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>)) <span class="comment">//"1"</span></div><div class="line"><span class="built_in">JSON</span>.stringify(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">//""2016-09-20T02:26:38.294Z""</span></div><div class="line"></div><div class="line"><span class="built_in">JSON</span>.stringify()方法会忽略对象的不可遍历属性</div><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</div><div class="line">  <span class="string">'foo'</span>: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">'bar'</span>: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">JSON</span>.stringify(obj); <span class="comment">// &#123;"foo":1&#125;]</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="3-2-参数"><a href="#3-2-参数" class="headerlink" title="3-2. 参数"></a>3-2. 参数</h6><ul>
<li>JSON.stringify()除序列化的javascript对象外,还可以接受两个参数,这两个参数用于指定以不同的方式序列化JavaScript对象.</li>
<li>第一个参数是一个过滤器,可以是一个数组,也可以是一个函数</li>
<li>第二个参数是一个选项,在JSON字符串中保留缩进</li>
</ul>
<ol>
<li><p>当stringify()方法的第二个参数是一个数组时,这时相当于实现一个过滤器的功能<br>过滤器只对对象的第一层属性有效</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var jsonObj = &#123;</div><div class="line">    <span class="string">"title"</span>:<span class="string">"javascript"</span>,</div><div class="line">    <span class="string">"group"</span>:&#123;</div><div class="line">        <span class="string">"a"</span>:<span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">JSON.stringify(jsonObj,[<span class="string">"group"</span>,<span class="string">"a"</span>]) // &#123;<span class="string">"group"</span>:&#123;<span class="string">"a"</span>:<span class="number">1</span>&#125;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>过滤器对数组无效</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jsonObj =[<span class="number">1</span>,<span class="number">2</span>];</div><div class="line"><span class="built_in">JSON</span>.stringify(jsonObj,[<span class="string">"0"</span>])<span class="comment">//"[1,2]"</span></div></pre></td></tr></table></figure>
</li>
<li><p>stringify()方法的第二个参数也可以是一个函数。<br>传入的函数接收两个参数，属性(键)名和属性值</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">JSON.stringify(&#123;a:<span class="number">1</span>,b:<span class="number">2</span>&#125;,<span class="keyword">function</span>(key, <span class="keyword">value</span>)&#123;</div><div class="line">  <span class="keyword">if</span> (typeof <span class="keyword">value</span> === <span class="string">"number"</span>) &#123;</div><div class="line">    <span class="keyword">value</span> = <span class="number">2</span> * <span class="keyword">value</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">value</span>;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// "&#123;"a":2,"b":4&#125;"</span></div></pre></td></tr></table></figure>
</li>
<li><p>注意:属性名只能是字符串，而在值并非键值对儿结构的值时，键名可以是空字符串</p>
</li>
<li>stringify()方法还可以接受第三个参数，用于增加返回的JSON字符串的可读性</li>
<li>如果是数字，表示每个属性前面添加的空格(最多不超过10个)</li>
<li><p>如果是字符串(不超过10个字符)，则该字符串会添加在每行前面</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">JSON.stringify(&#123; p1:<span class="number">1</span>, p2:<span class="number">2</span> &#125;, null, '<span class="string">|-');</span></div><div class="line">返回:<span class="string">"&#123;</span></div><div class="line"><span class="string">|-"</span>p1<span class="string">": 1,</span></div><div class="line"><span class="string">|-"</span>p2<span class="string">": 2</span></div><div class="line">&#125;<span class="string">"</span></div></pre></td></tr></table></figure>
</li>
<li><p>toJSON();JSON.stringify()还是不能满足对某些对象进行自定义序列化的需求。在这些情况下,可以通过对象上调用toJSON()方法,返回其自身的JSON数据格式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="string">'foo'</span>,</div><div class="line">  <span class="attr">toJSON</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'bar'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">x</span>: o&#125;);<span class="comment">// '&#123;"x":"bar"&#125;'</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="四-JSON对象的parse-方法。"><a href="#四-JSON对象的parse-方法。" class="headerlink" title="四.JSON对象的parse()方法。"></a>四.JSON对象的parse()方法。</h5><ul>
<li>JSON.parse方法用于将JSON字符串转化成对象</li>
</ul>
<ol>
<li>如果传入的字符串不是有效的JSON格式，JSON.parse方法将报错</li>
<li>JSON.parse()方法也可以接收一个函数参数，在每个键值对儿上调用，这个函数被称为还原函数(reviver)。该函数接收两个参数，一个键和一个值，返回一个值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">如果还原函数返回<span class="literal">undefined</span>，则表示要从结果中删除相应的键；</div><div class="line">如果返回其他值，则将该值插入到结果中</div><div class="line"><span class="keyword">var</span> o = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a":1,"b":2&#125;'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (key === <span class="string">''</span>)&#123;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (key === <span class="string">'a'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> value + <span class="number">10</span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">o.a <span class="comment">// 11</span></div><div class="line">o.b <span class="comment">// undefined</span></div><div class="line"></div><div class="line">在将日期字符串转换为<span class="built_in">Date</span>对象时，经常要用到还原函数</div><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="string">"title"</span>: <span class="string">"javascript"</span>,</div><div class="line">    <span class="string">"date"</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2016</span>,<span class="number">9</span>,<span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> jsonStr = <span class="built_in">JSON</span>.stringify(book);</div><div class="line"><span class="comment">//'&#123;"title":"javascript","date":"2016-09-30T16:00:00.000Z"&#125;''</span></div><div class="line"><span class="built_in">console</span>.log(jsonStr)</div><div class="line"></div><div class="line"><span class="keyword">var</span> bookCopy = <span class="built_in">JSON</span>.parse(jsonStr,<span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(key == <span class="string">'date'</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(bookCopy.date.getFullYear());<span class="comment">//2016</span></div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>()类似于<span class="built_in">JSON</span>.parse()方法，可以将json字符串转换为json对象</div><div class="line"><span class="built_in">eval</span>(<span class="string">'('</span> + <span class="string">'&#123;"a":1&#125;'</span>+<span class="string">')'</span>).a;<span class="comment">//1</span></div><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a":1&#125;'</span>).a;<span class="comment">//1</span></div><div class="line"></div><div class="line"><span class="built_in">eval</span>(<span class="string">'('</span> + <span class="string">'&#123;"a":alert(1)&#125;'</span>+<span class="string">')'</span>).a;<span class="comment">//弹出1</span></div><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a":alert(1)&#125;'</span>).a;<span class="comment">//报错</span></div><div class="line">但是，<span class="built_in">eval</span>()可以执行不符合<span class="built_in">JSON</span>格式的代码，有可能会包含恶意代码</div><div class="line">所以，还是要尽量少使用<span class="built_in">eval</span>()</div></pre></td></tr></table></figure>
<h5 id="何时是JSON，何时不是JSON？"><a href="#何时是JSON，何时不是JSON？" class="headerlink" title="何时是JSON，何时不是JSON？"></a>何时是JSON，何时不是JSON？</h5>
      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JSON/">JSON</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Notes/">Notes</a></li></ul>

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
      </div>
      
        <div align="center" style="margin-top: 30px;"><hr class="hr" style="margin:0px; height:3px;"></div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2017 岁月如冰河 All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    


  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>


  <script src="/js/home.js"></script>








  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            岁月如冰河
          </div>
          <div class="panel-body">
            Copyright © 2017 胡温柔 All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  

	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>


</body>
</html>